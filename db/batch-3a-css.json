[
  {
    "title": "z-index only works on positioned or flex/grid items",
    "category": "gotcha",
    "tags": ["css", "z-index", "stacking-context", "positioning"],
    "problem": "Setting z-index on an element has no effect even though the value is set correctly. Elements with lower z-index still appear on top.",
    "solution": "z-index only works on elements that have a position value other than static (i.e. relative, absolute, fixed, sticky), or on flex/grid children. Apply position: relative as the minimum fix:\n\n```css\n.my-element {\n  position: relative; /* required for z-index to work */\n  z-index: 10;\n}\n```",
    "why": "The CSS stacking algorithm ignores z-index for statically positioned elements. Without a positioning context, the browser treats all such elements as z-index: auto and stacks them in document order.",
    "gotchas": [
      "Flex and grid children can use z-index without position being set — this is a common source of inconsistency across layouts.",
      "Adding z-index creates a new stacking context, which can trap child elements below siblings of the parent.",
      "z-index values are only compared within the same stacking context — a z-index of 9999 inside a stacking context with z-index: 1 will lose to a sibling with z-index: 2."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["z-index", "stacking context", "position", "layering", "overlap"],
    "severity": "major",
    "context": "When elements visually overlap and the expected stacking order is wrong.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "Flexbox children overflow container due to min-width: auto",
    "category": "gotcha",
    "tags": ["css", "flexbox", "min-width", "overflow"],
    "problem": "A flex child containing text or a wide element overflows its flex container even when flex: 1 or flex-shrink: 1 is set. The container does not shrink the child as expected.",
    "solution": "Set min-width: 0 on the flex child. The default min-width for flex items is auto, which prevents shrinking below the content's intrinsic size:\n\n```css\n.flex-container {\n  display: flex;\n}\n\n.flex-child {\n  flex: 1;\n  min-width: 0; /* allows the child to shrink below its content size */\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n```",
    "why": "The CSS Flexbox specification sets the minimum size of flex items to min-content by default (min-width: auto). This prevents them from shrinking smaller than their content, which overrides flex-shrink.",
    "gotchas": [
      "The same issue applies to grid children — set min-width: 0 or min-height: 0 as needed.",
      "The problem is especially common with text truncation inside flex layouts.",
      "Setting overflow: hidden on the child also implicitly sets min-width to 0 in some browsers, but relying on that is fragile."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["flexbox", "min-width", "overflow", "shrink", "truncation", "flex item"],
    "severity": "major",
    "context": "Flex children with text or nested content that overflows the flex container unexpectedly.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "Margin collapse between sibling and parent elements",
    "category": "gotcha",
    "tags": ["css", "margin", "collapse", "block-formatting-context"],
    "problem": "Vertical margins between block elements collapse into a single margin equal to the largest of the two. Margins also collapse between a parent and its first/last child when there is no border, padding, or clearance between them.",
    "solution": "To prevent collapse, introduce a block formatting context or add separation:\n\n```css\n/* Option 1: add padding or border to parent */\n.parent {\n  padding-top: 1px; /* prevents margin collapse with first child */\n}\n\n/* Option 2: use overflow on parent */\n.parent {\n  overflow: hidden; /* creates BFC, stops margin collapse */\n}\n\n/* Option 3: use display: flow-root (modern, no side effects) */\n.parent {\n  display: flow-root;\n}\n\n/* Option 4: use gap in flex/grid instead of margins */\n.container {\n  display: flex;\n  flex-direction: column;\n  gap: 1rem; /* gap never collapses */\n}\n```",
    "why": "Margin collapsing is a CSS feature designed to give consistent spacing in flowing text documents. It only applies to block-level elements in normal flow — it does not happen in flex or grid containers.",
    "gotchas": [
      "Margins never collapse inside flex or grid containers.",
      "Negative margins can collapse in unexpected ways — the result is the largest positive margin minus the absolute value of the most negative margin.",
      "Margins do not collapse if elements are separated by padding, border, clearance, or if either creates a BFC.",
      "Margin collapse also applies to empty blocks with no height, border, or padding — a block with only a margin can collapse with adjacent siblings."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["margin collapse", "block formatting context", "BFC", "vertical margin", "spacing"],
    "severity": "moderate",
    "context": "Unexpected spacing between block elements or between a parent and its children.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "100vh causes overflow on mobile due to browser chrome",
    "category": "gotcha",
    "tags": ["css", "viewport", "mobile", "100vh", "dvh"],
    "problem": "An element set to height: 100vh extends beyond the visible screen on mobile browsers. The URL bar and bottom navigation bar are not accounted for, causing a scroll or cutoff.",
    "solution": "Use the dynamic viewport unit dvh (dynamic viewport height), or the svh/lvh variants depending on the desired behavior:\n\n```css\n/* Modern approach: dvh adjusts as browser chrome appears/disappears */\n.hero {\n  height: 100dvh;\n}\n\n/* svh = small viewport (browser chrome visible) */\n.section {\n  min-height: 100svh;\n}\n\n/* Fallback for older browsers */\n.hero {\n  height: 100vh; /* fallback */\n  height: 100dvh; /* override for supporting browsers */\n}\n```",
    "why": "On mobile browsers, the viewport height (100vh) is calculated based on the maximum viewport size — i.e., without the browser chrome. When the URL bar is visible, the actual visible area is smaller, so 100vh overflows.",
    "gotchas": [
      "dvh, svh, and lvh have broad support as of 2023 but check caniuse for your target browsers.",
      "On desktop, 100vh and 100dvh are equivalent since there is no dynamic chrome.",
      "Using 100svh gives the most conservative (always-fits) measurement, useful for fixed full-screen layouts."
    ],
    "language": "css",
    "framework": null,
    "environment": ["mobile", "ios safari", "chrome android"],
    "error_messages": [],
    "keywords": ["100vh", "mobile viewport", "dvh", "svh", "browser chrome", "viewport units"],
    "severity": "major",
    "context": "Full-screen sections or hero components that overflow on mobile browsers.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "CSS Grid auto-fill vs auto-fit: behavior with empty tracks",
    "category": "pattern",
    "tags": ["css", "grid", "auto-fill", "auto-fit", "responsive"],
    "problem": "auto-fill and auto-fit in CSS Grid repeat() look similar but behave differently when there are fewer items than columns, causing unexpected layout gaps or stretched items.",
    "solution": "Use auto-fit when you want items to stretch and fill the row. Use auto-fill when you want empty tracks to be preserved:\n\n```css\n/* auto-fit: empty tracks collapse, items stretch to fill */\n.grid-autofit {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n  gap: 1rem;\n}\n\n/* auto-fill: empty tracks are kept, items don't stretch */\n.grid-autofill {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n  gap: 1rem;\n}\n```\n\nWith 2 items in a 4-column grid: auto-fit gives each item 50% width; auto-fill keeps all 4 columns and the 2 items take 25% each.",
    "why": "auto-fit collapses empty tracks to 0 width, so the remaining items expand via 1fr. auto-fill creates all tracks regardless of content, so 1fr is divided among all possible tracks including empty ones.",
    "gotchas": [
      "The difference is only visible when the number of items is less than the maximum number of columns.",
      "Both produce identical results when the row is fully populated.",
      "Combining with minmax() is the standard responsive grid pattern — minmax(min, 1fr) prevents items from going below a minimum size."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["auto-fill", "auto-fit", "grid", "responsive grid", "repeat", "minmax"],
    "severity": "tip",
    "context": "Building responsive card grids without media queries.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "CSS transform creates a new stacking context",
    "category": "gotcha",
    "tags": ["css", "transform", "stacking-context", "z-index"],
    "problem": "Applying a CSS transform to an element causes it and its children to behave unexpectedly in terms of z-index layering, or causes fixed-position children to no longer be fixed relative to the viewport.",
    "solution": "Be aware that transform (along with opacity < 1, filter, will-change: transform, etc.) creates a new stacking context and a new containing block for fixed/absolute children:\n\n```css\n/* This parent will trap fixed children relative to itself, not viewport */\n.parent {\n  transform: translateZ(0); /* creates stacking context + containing block */\n}\n\n.child {\n  position: fixed; /* now fixed to .parent, not the viewport! */\n  top: 0;\n}\n\n/* Solution: move fixed elements outside of transformed ancestors */\n```",
    "why": "The CSS specification defines that transformed elements create a containing block for all positioned descendants, including fixed-position ones. This overrides the viewport as the reference for position: fixed.",
    "gotchas": [
      "opacity: 0.99 also creates a stacking context — even fractional opacity values trigger this.",
      "will-change: transform creates the stacking context proactively, before the animation starts.",
      "filter: none does NOT create a stacking context, but any non-none filter value does.",
      "This is a frequent source of bugs with sticky headers or modal overlays inside transformed containers."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["transform", "stacking context", "fixed positioning", "containing block", "z-index", "opacity"],
    "severity": "major",
    "context": "When position: fixed elements stop being fixed, or z-index layering breaks after adding a transform.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "position: sticky requirements — all must be met",
    "category": "pattern",
    "tags": ["css", "sticky", "positioning", "scroll"],
    "problem": "An element with position: sticky does not stick — it scrolls away like a normal element.",
    "solution": "All of the following must be true for sticky to work:\n\n```css\n.sticky-header {\n  position: sticky;\n  top: 0; /* threshold offset is REQUIRED — sticky won't work without it */\n}\n\n/* The parent must have:\n   1. A defined height (or content that causes overflow)\n   2. NOT overflow: hidden or overflow: auto (which clips sticky)\n   3. Enough scrollable content past the sticky element\n*/\n\n/* Common full-page sticky nav pattern */\nbody {\n  /* no overflow: hidden here */\n}\n\nnav {\n  position: sticky;\n  top: 0;\n  z-index: 100;\n}\n```",
    "why": "Sticky positioning works within its scroll container. The element sticks relative to the nearest scrolling ancestor. If that ancestor has overflow: hidden or a fixed height with no scroll, the sticky element has nowhere to stick.",
    "gotchas": [
      "A sticky element only sticks within the bounds of its parent — once the parent scrolls out of view, the sticky element goes with it.",
      "overflow: hidden on any ancestor will break sticky positioning.",
      "The offset property (top, left, etc.) is mandatory — without it the element won't stick even if everything else is correct.",
      "In Safari, position: -webkit-sticky may be needed for older versions."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["sticky", "position sticky", "scroll", "overflow", "stuck", "header"],
    "severity": "major",
    "context": "Implementing sticky navigation bars, table headers, or sidebars.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "overflow: hidden on ancestor breaks position: sticky",
    "category": "gotcha",
    "tags": ["css", "sticky", "overflow", "positioning"],
    "problem": "A position: sticky element stops working after adding overflow: hidden to a parent container.",
    "solution": "Find and remove overflow: hidden (or overflow: auto/scroll) from all ancestors of the sticky element. If clipping is needed for another reason, restructure the DOM:\n\n```css\n/* BREAKS sticky */\n.wrapper {\n  overflow: hidden; /* clips the sticky child's scroll container */\n}\n\n.sticky-nav {\n  position: sticky;\n  top: 0; /* has no effect — overflow hidden is the culprit */\n}\n\n/* FIX: remove overflow hidden from wrapper, or wrap differently */\n.outer-clip {\n  /* use clip-path or a pseudo-element for visual clipping instead */\n  clip-path: inset(0); /* clips visually but does not affect scroll container */\n}\n```",
    "why": "overflow: hidden (and auto/scroll) establishes a new scroll container. A sticky element positions itself relative to its nearest scrolling ancestor — when that ancestor is clipped, the sticky threshold is reached immediately and the element appears not to stick.",
    "gotchas": [
      "overflow: clip (CSS Overflow Module Level 4) clips visually without creating a scroll container, making it safe for sticky elements.",
      "This bug can be caused by a deeply nested ancestor — use DevTools to inspect the full ancestor chain.",
      "overflow: visible is the only value that does not create a scroll container."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["overflow hidden", "sticky broken", "scroll container", "clip", "ancestor"],
    "severity": "major",
    "context": "Sticky elements inside wrappers that use overflow: hidden for layout or aesthetic reasons.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "CSS contain property for rendering performance isolation",
    "category": "pattern",
    "tags": ["css", "contain", "performance", "layout", "paint"],
    "problem": "Complex or frequently updated DOM sections cause expensive full-page layout recalculations and repaints, degrading performance.",
    "solution": "Use the contain property to isolate a subtree from the rest of the page's layout and paint calculations:\n\n```css\n/* layout: element's size won't affect siblings */\n/* paint: element won't paint outside its bounds */\n/* style: CSS counters/quotes don't leak out */\n\n.card {\n  contain: layout paint; /* most common combination */\n}\n\n/* contain: content is shorthand for layout paint style */\n.widget {\n  contain: content;\n}\n\n/* contain: strict also adds size containment */\n.isolated-panel {\n  contain: strict;\n  width: 400px;\n  height: 300px; /* size must be explicit with strict */\n}\n```",
    "why": "Without containment, any change inside an element may trigger a layout recalculation for the entire page. contain tells the browser that the element is independent, so it can skip global recalculations and limit paint regions.",
    "gotchas": [
      "contain: strict requires explicit size — without it the element collapses to 0x0.",
      "contain: layout creates a new formatting context, which affects margin collapse and float behavior.",
      "contain: paint also creates a stacking context and a new absolute positioning containing block.",
      "content-visibility: auto uses containment automatically and is a higher-level API for off-screen performance."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["contain", "performance", "layout containment", "paint containment", "rendering isolation"],
    "severity": "tip",
    "context": "Large lists, dashboards, or frequently updating components where layout thrashing is a concern.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "aspect-ratio replaces the padding-top hack for responsive boxes",
    "category": "pattern",
    "tags": ["css", "aspect-ratio", "responsive", "video", "images"],
    "problem": "Maintaining a responsive element with a fixed aspect ratio (e.g. 16:9 video container) required the fragile padding-top percentage hack and absolute positioning of child content.",
    "solution": "Use the native aspect-ratio property:\n\n```css\n/* Modern approach */\n.video-container {\n  width: 100%;\n  aspect-ratio: 16 / 9;\n}\n\n.square-card {\n  width: 200px;\n  aspect-ratio: 1; /* shorthand for 1 / 1 */\n}\n\n/* Old padding hack — no longer needed */\n/* .video-container {\n  position: relative;\n  padding-top: 56.25%; /* 9/16 = 0.5625 */\n}\n.video-container iframe {\n  position: absolute;\n  top: 0; left: 0;\n  width: 100%; height: 100%;\n} */\n```",
    "why": "The padding-top hack exploited the fact that percentage padding is relative to the element's width. aspect-ratio is a proper CSS property that achieves the same result with far less code and no need for absolute positioning.",
    "gotchas": [
      "If both width and height are explicitly set, aspect-ratio is ignored.",
      "aspect-ratio works on replaced elements like img and video, respecting their intrinsic ratio unless overridden.",
      "Browser support is excellent as of 2022. Fallback to the padding hack only if supporting very old browsers."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["aspect-ratio", "responsive", "16:9", "padding hack", "video embed", "intrinsic ratio"],
    "severity": "tip",
    "context": "Responsive media embeds, cards, or any element that must maintain a fixed width-to-height ratio.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "clamp() for fluid typography without media queries",
    "category": "pattern",
    "tags": ["css", "clamp", "typography", "fluid", "responsive"],
    "problem": "Font sizes need to scale smoothly between a minimum and maximum based on viewport width, but using media queries creates abrupt size jumps.",
    "solution": "Use clamp() with a viewport-relative middle value:\n\n```css\n/* clamp(min, preferred, max) */\nh1 {\n  font-size: clamp(1.5rem, 4vw + 1rem, 3rem);\n  /* min: 1.5rem, scales with viewport, max: 3rem */\n}\n\nbody {\n  font-size: clamp(1rem, 1.5vw + 0.5rem, 1.25rem);\n}\n\n/* For spacing too */\n.section {\n  padding: clamp(1rem, 5vw, 3rem);\n}\n```\n\nThe formula `viewport_value + rem_offset` ensures the font never goes completely flat — the rem part preserves a base size even at zero viewport width.",
    "why": "clamp() is a CSS math function that clamps a value between a min and max. The middle value (preferred) is typically a viewport-relative unit combined with a fixed unit to create smooth, proportional scaling.",
    "gotchas": [
      "Using only vw as the middle value (e.g. clamp(1rem, 4vw, 3rem)) causes the text to be 0 at zero viewport width — add a rem or px offset to prevent this.",
      "clamp() can be used for any CSS property that accepts numeric values, not just font-size.",
      "Test your clamp values at the min and max viewport widths to confirm the clamping takes effect where expected."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["clamp", "fluid typography", "vw", "responsive font", "viewport", "math functions"],
    "severity": "tip",
    "context": "Responsive typography systems that scale smoothly across all viewport sizes.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": ":has() selector — CSS parent selector and relational queries",
    "category": "pattern",
    "tags": ["css", "has", "selector", "parent", "relational"],
    "problem": "CSS historically had no way to style a parent element based on its children, requiring JavaScript to add/remove classes.",
    "solution": "Use the :has() pseudo-class to select elements based on their descendants:\n\n```css\n/* Style a card that contains an image */\n.card:has(img) {\n  display: grid;\n  grid-template-rows: auto 1fr;\n}\n\n/* Style a form when it has an invalid input */\nform:has(:invalid) {\n  border: 2px solid red;\n}\n\n/* Style a label that is followed by a checked checkbox */\nlabel:has(+ input:checked) {\n  font-weight: bold;\n  color: green;\n}\n\n/* Style a section that does NOT have an h2 */\nsection:not(:has(h2)) {\n  padding-top: 0;\n}\n```",
    "why": ":has() implements relational querying in CSS. It is a functional pseudo-class that accepts a relative selector list and matches if any of the selectors match relative to the subject element.",
    "gotchas": [
      ":has() cannot be used inside another :has() (no nesting of :has in most browsers).",
      ":has() has no performance impact if used reasonably — browsers optimize it. Avoid very broad selectors like *:has(*).",
      "As of 2024, :has() is supported in all modern browsers. Safari added it first.",
      ":has() with :hover can create interesting interactive effects without JavaScript."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": [":has", "parent selector", "relational selector", "child selector", "CSS4"],
    "severity": "tip",
    "context": "Styling parent or sibling elements based on the state or presence of their children.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "Container queries for component-scoped responsive design",
    "category": "pattern",
    "tags": ["css", "container-queries", "responsive", "component", "cqw"],
    "problem": "Media queries respond to the viewport size, making it impossible to create truly reusable components that adapt to their own container width rather than the page width.",
    "solution": "Use @container queries after defining a containment context on the parent:\n\n```css\n/* 1. Define the container */\n.card-wrapper {\n  container-type: inline-size; /* or size for both axes */\n  container-name: card; /* optional name for specific targeting */\n}\n\n/* 2. Query the container inside */\n@container card (min-width: 400px) {\n  .card {\n    display: grid;\n    grid-template-columns: 200px 1fr;\n  }\n}\n\n@container (min-width: 600px) {\n  .card__title {\n    font-size: 1.5rem;\n  }\n}\n\n/* Container query units: cqw, cqh, cqi, cqb */\n.card__image {\n  width: 50cqw; /* 50% of the container's width */\n}\n```",
    "why": "Container queries decouple component layout from the viewport, enabling truly reusable design systems. A sidebar card and a main-column card can use identical markup but adopt different layouts based on their actual available space.",
    "gotchas": [
      "A container cannot query itself — the query applies to elements inside the container, not the container element itself.",
      "container-type: inline-size only tracks the inline (horizontal) axis. Use size to track both axes.",
      "Container query units (cqw, cqh) are relative to the nearest container ancestor.",
      "Adding container-type changes how the element participates in layout — inline-size creates a block formatting context."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["container queries", "@container", "cqw", "responsive component", "container-type", "inline-size"],
    "severity": "tip",
    "context": "Design systems and component libraries where the same component is used in different layout contexts.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "CSS Subgrid for aligning nested elements to parent grid tracks",
    "category": "pattern",
    "tags": ["css", "grid", "subgrid", "alignment", "nested"],
    "problem": "In a grid of cards, content inside each card (like titles and descriptions) cannot align across cards without JavaScript measurement, because each card is its own formatting context.",
    "solution": "Use subgrid to make a grid item's children participate in the parent grid's tracks:\n\n```css\n.grid {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-template-rows: auto auto auto; /* shared row tracks */\n  gap: 1rem;\n}\n\n.card {\n  display: grid;\n  grid-row: span 3; /* occupy 3 rows */\n  grid-template-rows: subgrid; /* inherit parent row tracks */\n}\n\n/* Now .card's children align to the parent grid's rows */\n.card__image { grid-row: 1; }\n.card__title { grid-row: 2; }\n.card__body  { grid-row: 3; }\n```",
    "why": "Without subgrid, each grid item is an independent layout context — its children cannot align with children in sibling items. Subgrid bridges this gap by propagating the parent's track definitions into the child grid.",
    "gotchas": [
      "Subgrid is supported in all modern browsers as of 2023 (Chrome 117+, Firefox 71+, Safari 16+).",
      "Subgrid can be applied to rows, columns, or both independently.",
      "Gap on the parent grid is inherited by the subgrid — the subgrid does not define its own gap unless explicitly set.",
      "You must span the correct number of rows/columns on the parent grid item for subgrid to work as expected."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["subgrid", "grid", "nested grid", "alignment", "card layout", "track"],
    "severity": "tip",
    "context": "Card grids or multi-column layouts where child elements need cross-card alignment.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "CSS scroll-snap for controlled scroll experiences",
    "category": "pattern",
    "tags": ["css", "scroll-snap", "carousel", "ux", "scroll"],
    "problem": "Building carousels or full-page scroll experiences requires JavaScript scroll event listeners and complex math to snap to items, leading to janky behavior.",
    "solution": "Use CSS scroll-snap to declaratively control scroll stopping points:\n\n```css\n/* Scroll container */\n.carousel {\n  display: flex;\n  overflow-x: auto;\n  scroll-snap-type: x mandatory; /* or 'proximity' for softer snap */\n  -webkit-overflow-scrolling: touch;\n  gap: 1rem;\n  scroll-padding: 1rem; /* offset snap point from edge */\n}\n\n/* Snap children */\n.carousel__item {\n  flex: 0 0 100%;\n  scroll-snap-align: start; /* or center, end */\n}\n\n/* Full-page vertical scroll */\n.page-sections {\n  height: 100dvh;\n  overflow-y: scroll;\n  scroll-snap-type: y mandatory;\n}\n\n.section {\n  height: 100dvh;\n  scroll-snap-align: start;\n}\n```",
    "why": "scroll-snap-type on the container defines the snap axis and strictness. scroll-snap-align on children defines where the snap point is on each item. The browser handles the physics natively, resulting in smooth, performant snapping.",
    "gotchas": [
      "mandatory snapping can trap users if items are shorter than the container — prefer proximity in those cases.",
      "scroll-padding on the container offsets snap points, useful when a sticky header overlaps content.",
      "overscroll-behavior: contain on the scroll container prevents scroll chaining to parent containers.",
      "JavaScript's scrollIntoView({ behavior: 'smooth' }) respects snap points."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["scroll-snap", "carousel", "snap", "scroll-snap-type", "scroll-snap-align", "full-page scroll"],
    "severity": "tip",
    "context": "Image carousels, full-page sections, or any scroll-based navigation.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "backdrop-filter for frosted glass effects",
    "category": "pattern",
    "tags": ["css", "backdrop-filter", "glass", "blur", "visual"],
    "problem": "Creating a frosted-glass or blurred-background overlay effect on a header or modal traditionally required duplicating and blurring background content with JavaScript or SVG hacks.",
    "solution": "Use backdrop-filter to apply visual effects to the area behind an element:\n\n```css\n.glass-panel {\n  background: rgba(255, 255, 255, 0.2);\n  backdrop-filter: blur(10px) saturate(180%);\n  -webkit-backdrop-filter: blur(10px) saturate(180%); /* Safari */\n  border: 1px solid rgba(255, 255, 255, 0.3);\n  border-radius: 12px;\n}\n\n/* Frosted navbar */\nnav {\n  position: sticky;\n  top: 0;\n  background: rgba(0, 0, 0, 0.5);\n  backdrop-filter: blur(20px);\n  -webkit-backdrop-filter: blur(20px);\n}\n```",
    "why": "backdrop-filter applies filter functions (blur, brightness, contrast, etc.) to the content behind an element. The element itself must have some transparency for the effect to be visible.",
    "gotchas": [
      "The element must have a partially transparent background — backdrop-filter has no visible effect with background: opaque.",
      "backdrop-filter creates a stacking context.",
      "Performance can be high — the GPU composites the blurred backdrop. Use sparingly on mobile.",
      "-webkit-backdrop-filter is still required for Safari. The unprefixed version is supported in Chrome and Firefox.",
      "backdrop-filter does not work inside elements with overflow: hidden in some browser versions."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["backdrop-filter", "blur", "frosted glass", "glassmorphism", "transparency", "visual effect"],
    "severity": "tip",
    "context": "Modals, navbars, cards overlaid on images or blurred backgrounds.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "mix-blend-mode for creative text and image compositing",
    "category": "pattern",
    "tags": ["css", "mix-blend-mode", "compositing", "design", "text"],
    "problem": "Achieving overlay text effects like 'punch-out' text that shows the background through letters, or multiply/screen blending between images, requires graphic editor exports rather than CSS.",
    "solution": "Use mix-blend-mode to control how an element blends with elements behind it:\n\n```css\n/* Knockout text effect */\n.hero {\n  background: url('photo.jpg') center / cover;\n  display: grid;\n  place-items: center;\n}\n\n.hero__overlay {\n  background: white;\n  mix-blend-mode: multiply; /* white becomes transparent, dark colors show */\n  padding: 2rem;\n}\n\n.hero__title {\n  color: black;\n  font-size: 5rem;\n  font-weight: 900;\n  mix-blend-mode: multiply;\n}\n\n/* Darken mode for image overlays */\n.image-overlay {\n  background: rgba(0, 100, 200, 0.5);\n  mix-blend-mode: multiply;\n}\n```",
    "why": "mix-blend-mode applies Porter-Duff compositing modes to an element relative to what is below it in the stacking order. This enables effects that previously required image editing tools.",
    "gotchas": [
      "isolation: isolate on a container prevents an element from blending with content outside that container.",
      "mix-blend-mode creates a stacking context.",
      "The multiply mode makes white transparent and preserves dark colors — useful for logo overlays on colored backgrounds.",
      "Performance is generally good but complex blend modes on many elements can affect paint times."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["mix-blend-mode", "blending", "compositing", "multiply", "overlay", "knockout text"],
    "severity": "tip",
    "context": "Creative layouts, hero sections, image overlays, and design-heavy pages.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "CSS custom properties (variables) inheritance and scope",
    "category": "pattern",
    "tags": ["css", "custom-properties", "variables", "inheritance", "theming"],
    "problem": "CSS variables don't behave as expected — changes to a variable on a parent don't propagate, or a variable defined in a media query doesn't work, or a variable on :root isn't accessible in a shadow DOM.",
    "solution": "Understand CSS variable scoping and inheritance rules:\n\n```css\n/* Variables are inherited by default */\n:root {\n  --color-primary: #3b82f6;\n  --spacing-unit: 8px;\n}\n\n/* Override in a local scope */\n.dark-section {\n  --color-primary: #93c5fd; /* only affects this element and its descendants */\n}\n\n/* Variables in @media — valid but only set when condition matches */\n@media (prefers-color-scheme: dark) {\n  :root {\n    --color-primary: #93c5fd;\n  }\n}\n\n/* Fallback values */\n.button {\n  background: var(--button-bg, var(--color-primary, blue));\n  /* nested fallbacks are allowed */\n}\n\n/* Variables are NOT inherited across shadow DOM boundaries */\n/* Use CSS Parts or inheritable custom properties to pierce shadow DOM */\n```",
    "why": "CSS custom properties are inherited properties by default, meaning they cascade down the DOM tree. They are resolved at computed value time, allowing dynamic changes with JavaScript or media queries. They do not cross shadow DOM boundaries.",
    "gotchas": [
      "Variables defined inside @keyframes or @media only take effect when those rules are active.",
      "A variable with an invalid value for the property that uses it does not fall back to the fallback value — it uses the property's initial value instead.",
      "var() cannot be used for property names or media query conditions, only for values.",
      "Empty variable values (--foo: ;) are valid and differ from an unset variable."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["CSS variables", "custom properties", "var()", "theming", "inheritance", "scope"],
    "severity": "tip",
    "context": "Theming systems, dark mode, component-level style overrides.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "@layer for managing cascade specificity and ordering",
    "category": "pattern",
    "tags": ["css", "cascade-layers", "@layer", "specificity", "ordering"],
    "problem": "Third-party CSS (resets, component libraries) conflicts with custom styles, and increasing specificity to override styles leads to a specificity arms race that is hard to maintain.",
    "solution": "Use @layer to explicitly control the cascade order. Styles in later layers win over earlier layers, regardless of specificity:\n\n```css\n/* Declare layer order first (lower layers = lower priority) */\n@layer reset, base, components, utilities;\n\n/* Import third-party into a specific layer */\n@import url('normalize.css') layer(reset);\n\n/* Layer styles */\n@layer base {\n  a { color: blue; } /* specificity: 0-0-1 */\n}\n\n@layer components {\n  a { color: red; } /* wins over base layer a, even same specificity */\n}\n\n@layer utilities {\n  .text-green { color: green; } /* wins over all previous layers */\n}\n\n/* Unlayered styles win over all layers */\na { color: purple; } /* this wins over all @layer styles */\n```",
    "why": "@layer introduces a new origin in the cascade above specificity. Styles in a higher layer win regardless of selector specificity within a lower layer. This allows libraries to be safely wrapped in low-priority layers.",
    "gotchas": [
      "Styles not in any layer (unlayered) always win over layered styles — regardless of specificity.",
      "The order of @layer declarations (not definitions) determines priority — declare all layer names at the top of the stylesheet.",
      "Nesting layers is supported: @layer components.card { }.",
      "!important interacts with layers in the reverse order — !important in a lower layer wins over !important in a higher layer."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["@layer", "cascade layers", "specificity", "CSS cascade", "override", "priority"],
    "severity": "tip",
    "context": "Large CSS codebases, design systems, or projects that mix third-party CSS with custom styles.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "gap in flexbox vs margin for item spacing",
    "category": "pattern",
    "tags": ["css", "flexbox", "gap", "margin", "spacing"],
    "problem": "Adding margins to flex children for spacing creates unwanted outer margins on the first/last items, requiring negative margin hacks on the container or :first-child/:last-child overrides.",
    "solution": "Use the gap property on the flex container instead of margins on children:\n\n```css\n/* Modern approach */\n.flex-container {\n  display: flex;\n  gap: 1rem; /* uniform gap between all children, no outer edges */\n  flex-wrap: wrap;\n}\n\n/* row-gap and column-gap are the longhand properties */\n.flex-container {\n  display: flex;\n  flex-wrap: wrap;\n  row-gap: 1rem;    /* vertical gap between wrapped rows */\n  column-gap: 0.5rem; /* horizontal gap between items */\n}\n\n/* Old approach with margin hack -- avoid this */\n/* .flex-container { margin: -0.5rem; }\n.flex-item { margin: 0.5rem; } */\n```",
    "why": "gap (and its longhands row-gap, column-gap) applies spacing only between flex items, never on the outer edges. This is semantically correct and eliminates the need for negative margin hacks.",
    "gotchas": [
      "gap in flexbox has excellent browser support as of 2021 (Chrome 84+, Firefox 63+, Safari 14.1+).",
      "gap does not collapse like margins — a gap of 1rem between two items is always exactly 1rem.",
      "gap works in both flex and grid layouts with identical syntax.",
      "Percentage gap values in flexbox are relative to the inline size of the flex container."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["gap", "flexbox gap", "spacing", "row-gap", "column-gap", "margin hack"],
    "severity": "tip",
    "context": "Any flexbox layout requiring consistent spacing between items.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "overscroll-behavior to prevent scroll chaining",
    "category": "pattern",
    "tags": ["css", "overscroll-behavior", "scroll", "ux", "mobile"],
    "problem": "When a user scrolls to the end of a modal or scrollable panel, the scroll continues to the page behind it (scroll chaining). On mobile, this also triggers pull-to-refresh unintentionally.",
    "solution": "Use overscroll-behavior on the scrollable container:\n\n```css\n/* Prevent scroll from propagating to parent when this element reaches its edge */\n.modal-content {\n  overflow-y: auto;\n  overscroll-behavior-y: contain; /* stops chaining on vertical scroll */\n}\n\n/* Prevent pull-to-refresh on the whole page */\nbody {\n  overscroll-behavior-y: none;\n}\n\n/* Prevent diagonal scroll interference in a horizontal carousel */\n.carousel {\n  overflow-x: auto;\n  overscroll-behavior-x: contain;\n}\n```",
    "why": "By default, browsers chain scroll events — when a scroll container reaches its boundary, the scroll is passed to the parent container. overscroll-behavior: contain tells the browser to stop at the boundary.",
    "gotchas": [
      "overscroll-behavior: none also disables the bounce/rubber-band effect on iOS, which some users expect as visual feedback.",
      "Pull-to-refresh on Android Chrome is disabled when overscroll-behavior-y: none is set on body.",
      "The property must be set on the scrolling element itself, not its parent.",
      "overscroll-behavior is not supported in older Safari — use a touch event listener as fallback if needed."
    ],
    "language": "css",
    "framework": null,
    "environment": ["mobile", "ios", "android"],
    "error_messages": [],
    "keywords": ["overscroll-behavior", "scroll chaining", "pull-to-refresh", "modal scroll", "bounce"],
    "severity": "moderate",
    "context": "Modals, drawers, carousels, or any scrollable component inside a scrollable page.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "text-overflow: ellipsis requires three conditions",
    "category": "gotcha",
    "tags": ["css", "text-overflow", "ellipsis", "truncation", "whitespace"],
    "problem": "Setting text-overflow: ellipsis on an element has no effect — the text still wraps or overflows without showing the ellipsis character.",
    "solution": "All three of the following properties must be set together on the same element:\n\n```css\n/* All three are required for ellipsis to work on single line */\n.truncate {\n  white-space: nowrap;     /* 1. prevent text wrapping */\n  overflow: hidden;        /* 2. hide overflowing text */\n  text-overflow: ellipsis; /* 3. show ellipsis for the hidden part */\n  max-width: 200px;        /* container must have a constrained width */\n}\n\n/* Multi-line ellipsis (line-clamp) */\n.clamp {\n  display: -webkit-box;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 3; /* clamp to 3 lines */\n  overflow: hidden;\n  /* text-overflow: ellipsis not needed for line-clamp */\n}\n\n/* Modern single-property approach */\n.clamp-modern {\n  overflow: hidden;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  line-clamp: 2; /* standard property, limited support */\n  -webkit-box-orient: vertical;\n}\n```",
    "why": "text-overflow only applies when text overflows its container. Without white-space: nowrap, text wraps instead of overflowing. Without overflow: hidden, the overflow is visible rather than clipped.",
    "gotchas": [
      "The container must have a defined width — a flex or inline container without a width constraint won't trigger overflow.",
      "text-overflow applies to inline overflow only — for block overflow, use line-clamp.",
      "ellipsis is added on the last visible line — it does not count toward the overflow threshold.",
      "-webkit-line-clamp requires display: -webkit-box and -webkit-box-orient: vertical to work."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["text-overflow", "ellipsis", "truncation", "white-space nowrap", "overflow hidden", "line-clamp"],
    "severity": "moderate",
    "context": "Single-line text truncation in cards, table cells, or any fixed-width container.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "pointer-events: none to allow clicks through overlay elements",
    "category": "pattern",
    "tags": ["css", "pointer-events", "overlay", "click-through", "interaction"],
    "problem": "A decorative overlay (shimmer effect, gradient fade, loading skeleton) sits on top of interactive content and blocks clicks, hover states, and keyboard focus on elements below.",
    "solution": "Use pointer-events: none to make an element transparent to mouse and touch events:\n\n```css\n/* Overlay that doesn't block interaction */\n.shimmer-overlay {\n  position: absolute;\n  inset: 0;\n  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);\n  animation: shimmer 1.5s infinite;\n  pointer-events: none; /* clicks pass through to elements below */\n}\n\n/* Gradient fade at bottom of scrollable list */\n.list-fade::after {\n  content: '';\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  height: 60px;\n  background: linear-gradient(transparent, white);\n  pointer-events: none;\n}\n\n/* Re-enable for a specific child inside a none parent */\n.interactive-child {\n  pointer-events: auto;\n}\n```",
    "why": "pointer-events: none removes the element from the hit-testing process. Clicks, mouseover, and touch events fall through to the element behind it in the stacking order.",
    "gotchas": [
      "pointer-events: none also disables cursor changes — the element is completely transparent to the pointer.",
      "Children can re-enable pointer events with pointer-events: auto even if a parent has none.",
      "Elements with pointer-events: none are still rendered and still participate in layout.",
      "This property also works on SVG elements with additional values like visiblePainted."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["pointer-events", "click-through", "overlay", "interaction", "hit-testing", "transparent"],
    "severity": "tip",
    "context": "Decorative overlays, gradient fades, shimmer effects, or any visual layer that should not intercept user interaction.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "will-change: performance optimization with caveats",
    "category": "pattern",
    "tags": ["css", "will-change", "performance", "compositing", "animation"],
    "problem": "Animations are janky or cause layout repaints. Adding will-change is meant to fix this but is sometimes overused, causing performance regressions instead.",
    "solution": "Use will-change judiciously, only on elements that are about to be animated, and remove it after the animation:\n\n```css\n/* Apply just before animation starts (e.g., via JS on hover) */\n.card {\n  transition: transform 0.3s ease;\n}\n\n.card:hover {\n  will-change: transform; /* hints browser to promote to composite layer */\n  transform: scale(1.05);\n}\n\n/* Remove after animation via JS for long-lived elements */\nelement.addEventListener('transitionend', () => {\n  element.style.willChange = 'auto';\n});\n\n/* Never do this on many elements */\n/* * { will-change: transform; } -- defeats the purpose */\n\n/* For known persistent animations */\n.spinner {\n  will-change: transform; /* always spinning, OK to keep permanently */\n  animation: spin 1s linear infinite;\n}\n```",
    "why": "will-change tells the browser to promote an element to its own compositor layer before the animation starts, avoiding jank from promotion during the animation. However, each promoted layer consumes GPU memory — overuse wastes memory and can cause slowdowns.",
    "gotchas": [
      "will-change creates a new stacking context and a new containing block for positioned descendants.",
      "Applying will-change to too many elements exhausts GPU memory, especially on mobile.",
      "will-change: transform is a hint, not a guarantee — browsers may ignore it.",
      "Never use will-change as a performance fix without profiling first — it can make things worse."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["will-change", "compositing", "GPU layer", "animation performance", "jank", "transform"],
    "severity": "moderate",
    "context": "Performance optimization of CSS animations and transitions.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "prefers-reduced-motion for accessible animations",
    "category": "pattern",
    "tags": ["css", "accessibility", "animation", "motion", "media-query"],
    "problem": "CSS animations and transitions cause motion sickness or discomfort for users with vestibular disorders. There is no fallback for users who have enabled reduced motion in their OS settings.",
    "solution": "Use the prefers-reduced-motion media query to disable or tone down animations:\n\n```css\n/* Base animations */\n.button {\n  transition: transform 0.3s ease, box-shadow 0.3s ease;\n}\n\n.button:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 12px rgba(0,0,0,0.2);\n}\n\n/* Reduce or remove motion for users who prefer it */\n@media (prefers-reduced-motion: reduce) {\n  .button {\n    transition: box-shadow 0.1s ease; /* keep subtle visual feedback */\n  }\n\n  .button:hover {\n    transform: none; /* remove the movement */\n  }\n\n  /* Global approach: remove all transitions and animations */\n  *, *::before, *::after {\n    animation-duration: 0.01ms !important;\n    animation-iteration-count: 1 !important;\n    transition-duration: 0.01ms !important;\n  }\n}\n```",
    "why": "The prefers-reduced-motion media query reflects the user's OS-level 'Reduce Motion' setting. Respecting it is a WCAG 2.1 criterion (2.3.3 Animation from Interactions) and improves accessibility for millions of users.",
    "gotchas": [
      "Do not completely remove all visual feedback — non-moving transitions like opacity or color changes are usually acceptable.",
      "Auto-playing videos should also be paused when prefers-reduced-motion: reduce is active.",
      "The no-preference value does not mean the user wants animations — it means they haven't expressed a preference.",
      "JavaScript: window.matchMedia('(prefers-reduced-motion: reduce)') allows you to respect this in animations driven by JS."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["prefers-reduced-motion", "accessibility", "animation", "vestibular", "WCAG", "motion"],
    "severity": "major",
    "context": "Any website with CSS animations, transitions, or scroll effects.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "CSS nesting — native without preprocessors",
    "category": "pattern",
    "tags": ["css", "nesting", "native", "sass", "selector"],
    "problem": "Writing repeated parent selectors for variants and states makes CSS verbose. Previously required a preprocessor like Sass or Less.",
    "solution": "Use native CSS nesting (now baseline in all modern browsers):\n\n```css\n/* Native CSS nesting */\n.card {\n  background: white;\n  border-radius: 8px;\n\n  /* Nested selectors — & is the parent selector */\n  & .card__title {\n    font-size: 1.25rem;\n    font-weight: bold;\n  }\n\n  &:hover {\n    box-shadow: 0 4px 12px rgba(0,0,0,0.1);\n  }\n\n  &.card--featured {\n    border: 2px solid gold;\n  }\n\n  /* Nested media query */\n  @media (min-width: 768px) {\n    display: grid;\n    grid-template-columns: 200px 1fr;\n  }\n\n  /* Nesting without & — selects descendants */\n  img {\n    width: 100%;\n    border-radius: 8px 8px 0 0;\n  }\n}\n```",
    "why": "Native CSS nesting follows the same semantics as Sass nesting. The & symbol refers to the parent selector. Without &, the nested rule becomes a descendant selector.",
    "gotchas": [
      "Nesting without & (bare element selectors like img inside .card {}) is valid in the latest spec but had a rocky browser rollout — use & img { } for maximum compatibility.",
      "Specificity of nested selectors is calculated the same as if they were un-nested.",
      "CSS nesting does not support the parent-referencing patterns like &__element (BEM) without a full class — you must write the full class name.",
      "Browser support: Chrome 112+, Firefox 117+, Safari 17+."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["CSS nesting", "native nesting", "& selector", "preprocessor", "Sass", "BEM"],
    "severity": "tip",
    "context": "Modern CSS projects that want to reduce selector repetition without a build step.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "color-scheme for correct dark mode form controls and scrollbars",
    "category": "pattern",
    "tags": ["css", "color-scheme", "dark-mode", "form", "scrollbar"],
    "problem": "When implementing dark mode with custom CSS variables, browser-native UI elements (scrollbars, form inputs, checkboxes, date pickers) remain light, creating an inconsistent visual experience.",
    "solution": "Declare color-scheme to tell the browser the element's preferred color scheme:\n\n```css\n/* Tell the browser the page supports light and dark */\n:root {\n  color-scheme: light dark;\n}\n\n/* Force dark mode for native elements in dark context */\n.dark-panel {\n  color-scheme: dark;\n  background: #1a1a2e;\n  color: white;\n}\n\n/* Force light mode (e.g., an input in a dark card that should stay light) */\n.light-input {\n  color-scheme: light;\n}\n\n/* In HTML meta tag for initial paint */\n/* <meta name=\"color-scheme\" content=\"light dark\"> */\n```",
    "why": "color-scheme is an inherited CSS property that informs the browser of the color scheme for the rendering of form elements, scrollbars, and other native UI components. Without it, native controls always render in light mode.",
    "gotchas": [
      "color-scheme: light dark means the browser chooses based on the user's system preference — use prefers-color-scheme to make explicit per-context choices.",
      "Setting color-scheme also affects the Canvas API's default colors and the default link color.",
      "The meta tag version is important for avoiding a flash of incorrect theme on initial page load.",
      "color-scheme does not change the value of CSS system colors like ButtonFace — those update automatically when the scheme is set."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["color-scheme", "dark mode", "native controls", "scrollbar", "form elements", "system ui"],
    "severity": "moderate",
    "context": "Dark mode implementations where native browser UI elements look inconsistent.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "accent-color for theming native form controls",
    "category": "pattern",
    "tags": ["css", "accent-color", "form", "checkbox", "theming"],
    "problem": "Checkbox, radio, range, and progress native form elements are difficult to style and typically require completely hiding the native element and building a custom replacement from scratch.",
    "solution": "Use accent-color to apply a brand color to native form controls with one line of CSS:\n\n```css\n/* Global accent color */\n:root {\n  accent-color: #3b82f6; /* your brand color */\n}\n\n/* Per-element accent */\ninput[type=\"checkbox\"] {\n  accent-color: #10b981; /* green checkboxes */\n  width: 1.2em;\n  height: 1.2em;\n}\n\ninput[type=\"range\"] {\n  accent-color: #f59e0b; /* amber slider */\n}\n\nprogress {\n  accent-color: #6366f1; /* purple progress bar */\n}\n\n/* Dark mode adaptation */\n@media (prefers-color-scheme: dark) {\n  :root {\n    accent-color: #60a5fa; /* lighter blue for dark backgrounds */\n  }\n}\n```",
    "why": "accent-color is a CSS property that applies the specified color to the checked/active state of checkboxes, radios, progress bars, and range sliders — native elements that previously required JavaScript-driven custom components to style.",
    "gotchas": [
      "accent-color only affects the highlight/accent color of the control, not all parts — full custom styling may still require more work.",
      "The browser automatically adjusts contrast for the control's tick mark or thumb to remain readable against the accent color.",
      "Supported in Chrome 93+, Firefox 92+, Safari 15.4+.",
      "accent-color is inherited, so setting it on :root propagates to all form elements in the document."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["accent-color", "form controls", "checkbox", "radio", "range", "theming", "native styling"],
    "severity": "tip",
    "context": "Branding native form elements without replacing them with custom components.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "scroll-behavior: smooth for native smooth scrolling",
    "category": "pattern",
    "tags": ["css", "scroll-behavior", "smooth-scroll", "anchor", "ux"],
    "problem": "Clicking anchor links causes jarring instant jumps to the target section. JavaScript smooth scroll polyfills add complexity and may conflict with other scroll logic.",
    "solution": "Use scroll-behavior: smooth on the scroll container or html element:\n\n```css\n/* Global smooth scrolling */\nhtml {\n  scroll-behavior: smooth;\n}\n\n/* Only on specific containers */\n.sidebar-nav {\n  overflow-y: auto;\n  scroll-behavior: smooth;\n}\n\n/* Respect reduced motion preferences */\n@media (prefers-reduced-motion: reduce) {\n  html {\n    scroll-behavior: auto; /* disable smooth scroll for motion-sensitive users */\n  }\n}\n\n/* Also applies to scrollIntoView() and scrollTo() in JS */\n/* window.scrollTo({ top: 0, behavior: 'smooth' }) */\n```",
    "why": "scroll-behavior controls whether the browser uses smooth, animated scrolling or instant jumping when programmatic scrolling occurs (anchor navigation, scrollIntoView, scrollTo). smooth uses the browser's native animation, respecting the OS scroll speed settings.",
    "gotchas": [
      "scroll-behavior: smooth is ignored for users with prefers-reduced-motion: reduce in some browsers — but not all. Always add the media query override manually.",
      "Smooth scrolling can conflict with scroll-snap — test the combination carefully.",
      "On-page links that update the URL hash also trigger scroll-behavior.",
      "scroll-behavior does not affect touch-based momentum scrolling on mobile — the browser handles that independently."
    ],
    "language": "css",
    "framework": null,
    "environment": [],
    "error_messages": [],
    "keywords": ["scroll-behavior", "smooth scroll", "anchor links", "scrollIntoView", "UX"],
    "severity": "tip",
    "context": "Single-page sites with anchor navigation, table of contents, or back-to-top links.",
    "code_snippets": [],
    "version_info": null
  },
  {
    "title": "View Transitions API for animated page and state changes",
    "category": "pattern",
    "tags": ["css", "view-transitions", "animation", "SPA", "navigation"],
    "problem": "Animating between page states or routes in a multi-page app requires complex JavaScript, duplicated DOM, or costly opacity/transform choreography. SPA route transitions are difficult to implement smoothly.",
    "solution": "Use the View Transitions API to animate between document states with minimal code:\n\n```css\n/* CSS: define transition animations */\n::view-transition-old(root) {\n  animation: fade-out 0.3s ease forwards;\n}\n\n::view-transition-new(root) {\n  animation: fade-in 0.3s ease forwards;\n}\n\n@keyframes fade-out {\n  to { opacity: 0; }\n}\n\n@keyframes fade-in {\n  from { opacity: 0; }\n}\n\n/* Named transitions for specific elements */\n.hero-image {\n  view-transition-name: hero; /* must be unique on the page */\n}\n```\n\n```js\n// JavaScript: wrap state changes in startViewTransition\ndocument.startViewTransition(() => {\n  // Update the DOM here\n  updatePageContent();\n});\n\n// For SPA navigation:\ndocument.startViewTransition(async () => {\n  await router.navigate(newPath);\n});\n```",
    "why": "The View Transitions API captures before/after snapshots of the page, then crossfades them. Named elements (view-transition-name) are individually animated, enabling morphing effects between states without manual DOM cloning.",
    "gotchas": [
      "view-transition-name must be unique per page — duplicate names cause the transition to be skipped for those elements.",
      "Multi-page app (MPA) view transitions require the @view-transition { navigation: auto; } rule and are a newer addition.",
      "Not supported in Firefox as of early 2024 — use feature detection: if (!document.startViewTransition) { updateDOM(); return; }",
      "During a transition, the page is briefly frozen — avoid long-running DOM updates inside startViewTransition.",
      "Respect prefers-reduced-motion by wrapping transitions conditionally."
    ],
    "language": "css",
    "framework": null,
    "environment": ["chrome", "safari", "modern browsers"],
    "error_messages": [],
    "keywords": ["view transitions", "page animation", "startViewTransition", "SPA", "MPA", "route transition"],
    "severity": "tip",
    "context": "Single-page or multi-page apps that need smooth animated transitions between routes or UI states.",
    "code_snippets": [],
    "version_info": null
  }
]
