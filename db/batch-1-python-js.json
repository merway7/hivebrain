[
  {"title":"Mutable default arguments create shared state between calls","category":"gotcha","tags":["python","functions","mutable","default-args"],"problem":"Using a mutable object (list, dict, set) as a default argument causes it to be shared across all calls. def append_to(item, lst=[]): lst.append(item); return lst — calling it twice returns [1, 2] not [2].","solution":"Use None as the default and create a new object inside the function:\n\ndef append_to(item, lst=None):\n    if lst is None:\n        lst = []\n    lst.append(item)\n    return lst\n\nThis creates a fresh list on every call. The mutable default is evaluated once at function definition time, not at call time.","why":"Python evaluates default arguments once when the function is defined, not each time it's called. The default object is stored on the function object (func.__defaults__) and reused.","gotchas":["This also applies to dict and set defaults","Dataclass fields with mutable defaults need field(default_factory=list)","Even datetime.now() as a default captures definition time, not call time"],"language":"python","framework":null,"environment":[],"error_messages":[],"keywords":["mutable default","shared state","function arguments","default list","default dict"],"severity":"major","context":"When defining functions with list, dict, or set default parameters","code_snippets":[{"lang":"python","code":"# BAD\ndef add(item, lst=[]):\n    lst.append(item)\n    return lst\n\nadd(1)  # [1]\nadd(2)  # [1, 2] — NOT [2]!\n\n# GOOD\ndef add(item, lst=None):\n    if lst is None:\n        lst = []\n    lst.append(item)\n    return lst","description":"Mutable default argument fix"}],"version_info":null},
  {"title":"Circular import causes ImportError or partially initialized module","category":"gotcha","tags":["python","imports","circular","modules"],"problem":"Two modules importing each other cause ImportError: cannot import name 'X' from partially initialized module or AttributeError. Module A imports from B, B imports from A — one of them gets a partially loaded module.","solution":"Break the cycle with one of these approaches:\n\n1. Move the import inside the function that needs it (lazy import):\n   def my_func():\n       from module_b import something\n\n2. Restructure: extract shared code into a third module that both import.\n\n3. Use TYPE_CHECKING for type hints only:\n   from __future__ import annotations\n   from typing import TYPE_CHECKING\n   if TYPE_CHECKING:\n       from module_b import MyClass","why":"Python executes module code top-to-bottom on first import. If A imports B while A is still loading, B tries to import from A but A isn't fully initialized yet. The names B wants may not exist yet in A's namespace.","gotchas":["from module import name fails more often than import module with circular deps","__future__ annotations defers evaluation of type hints, avoiding runtime circular imports","Moving imports to the bottom of the file sometimes works but is fragile"],"language":"python","framework":null,"environment":[],"error_messages":["ImportError: cannot import name 'X' from partially initialized module","AttributeError: partially initialized module 'X' has no attribute 'Y'","most likely due to a circular import"],"keywords":["circular import","partially initialized","ImportError","module cycle"],"severity":"major","context":"When two or more Python modules import from each other","code_snippets":[{"lang":"python","code":"# Fix: lazy import inside function\ndef process():\n    from module_b import helper  # imported when called, not at load time\n    return helper()\n\n# Fix: TYPE_CHECKING guard for type hints\nfrom __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from module_b import MyClass","description":"Breaking circular imports"}],"version_info":null},
  {"title":"datetime.now() returns naive datetime without timezone","category":"gotcha","tags":["python","datetime","timezone","utc"],"problem":"datetime.now() returns a naive datetime (no timezone info). Comparing naive and aware datetimes raises TypeError. Code that works locally breaks in production because servers may be in different timezones.","solution":"Always use timezone-aware datetimes:\n\nfrom datetime import datetime, timezone\n\n# Get current time in UTC\nnow = datetime.now(timezone.utc)\n\n# NEVER use datetime.utcnow() — it returns naive despite the name!\n# It's deprecated in Python 3.12\n\n# Store as ISO format with timezone\ntimestamp = now.isoformat()  # '2024-01-15T10:30:00+00:00'\n\n# Parse back\nparsed = datetime.fromisoformat(timestamp)","why":"datetime.now() uses the system's local timezone but doesn't attach timezone info to the object. datetime.utcnow() converts to UTC but ALSO doesn't attach timezone info, making it look like local time. This causes bugs when comparing times across systems.","gotchas":["datetime.utcnow() is deprecated in Python 3.12 — use datetime.now(timezone.utc)","Comparing naive and aware datetimes raises TypeError: can't compare offset-naive and offset-aware","Use zoneinfo.ZoneInfo (Python 3.9+) instead of pytz for timezone conversions"],"language":"python","framework":null,"environment":[],"error_messages":["TypeError: can't compare offset-naive and offset-aware datetimes","DeprecationWarning: datetime.datetime.utcnow() is deprecated"],"keywords":["datetime timezone","naive datetime","utcnow deprecated","timezone aware","zoneinfo"],"severity":"major","context":"When working with dates and times in Python, especially across timezones","code_snippets":[{"lang":"python","code":"from datetime import datetime, timezone\nfrom zoneinfo import ZoneInfo  # Python 3.9+\n\n# Always use timezone-aware\nnow_utc = datetime.now(timezone.utc)\nnow_paris = datetime.now(ZoneInfo('Europe/Paris'))\n\n# Convert between timezones\nnow_utc.astimezone(ZoneInfo('US/Eastern'))","description":"Timezone-aware datetime usage"}],"version_info":"Python 3.9+ for zoneinfo, 3.12 deprecates utcnow()"},
  {"title":"requests.get() hangs forever without timeout parameter","category":"gotcha","tags":["python","requests","timeout","http","networking"],"problem":"requests.get(url) with no timeout parameter will hang indefinitely if the server never responds. No exception is raised — the process just blocks forever. This commonly happens in production with slow APIs or network issues.","solution":"ALWAYS pass a timeout parameter:\n\nimport requests\n\n# Timeout in seconds (connect_timeout, read_timeout)\nresponse = requests.get(url, timeout=(3.05, 27))\n\n# Or a single value for both\nresponse = requests.get(url, timeout=10)\n\n# For retries, use urllib3 retry:\nfrom requests.adapters import HTTPAdapter\nfrom urllib3.util.retry import Retry\n\nsession = requests.Session()\nretry = Retry(total=3, backoff_factor=0.5)\nsession.mount('http://', HTTPAdapter(max_retries=retry))\nsession.mount('https://', HTTPAdapter(max_retries=retry))","why":"The requests library does not set any default timeout. The underlying urllib3/socket layer will wait indefinitely for a response. This is a design choice — the library doesn't want to guess what timeout is appropriate for your use case.","gotchas":["timeout=(connect, read) — connect timeout is for establishing connection, read timeout is for waiting for data","A timeout of 0 is not the same as no timeout — it means 'fail immediately'","DNS resolution time is NOT included in the connect timeout"],"language":"python","framework":null,"environment":[],"error_messages":["requests.exceptions.ConnectTimeout","requests.exceptions.ReadTimeout","requests.exceptions.ConnectionError"],"keywords":["requests timeout","hang forever","connection timeout","read timeout","no response"],"severity":"critical","context":"Any HTTP call using the requests library without explicit timeout","code_snippets":[{"lang":"python","code":"import requests\n\n# BAD — hangs forever if server doesn't respond\nresponse = requests.get('https://api.example.com/data')\n\n# GOOD — fails after 10 seconds\nresponse = requests.get('https://api.example.com/data', timeout=10)\n\n# BEST — separate connect and read timeouts\nresponse = requests.get('https://api.example.com/data', timeout=(3.05, 27))","description":"Always set timeout on requests"}],"version_info":null},
  {"title":"f-string cannot contain backslash characters","category":"gotcha","tags":["python","f-string","string-formatting","syntax"],"problem":"Using backslashes inside f-string expressions raises SyntaxError. For example: f'{\"\\n\".join(items)}' fails. This is a common gotcha when trying to use escape sequences or regex in f-strings.","solution":"Assign the expression with backslash to a variable first:\n\n# BAD\nresult = f'{\"\\n\".join(items)}'  # SyntaxError\n\n# GOOD\nnewline = '\\n'\nresult = f'{newline.join(items)}'\n\n# Or use chr()\nresult = f'{chr(10).join(items)}'\n\n# Or don't use f-string for this\nresult = '\\n'.join(items)\n\n# Python 3.12+ lifts this restriction!","why":"Python's parser cannot handle backslash escapes inside the curly braces of f-strings in versions before 3.12. The f-string parser and the string escape parser conflict.","gotchas":["Python 3.12 removes this restriction — backslashes work in f-string expressions","This also affects raw strings and regex patterns inside f-strings","chr(10) for newline and chr(9) for tab are workarounds"],"language":"python","framework":null,"environment":[],"error_messages":["SyntaxError: f-string expression part cannot include a backslash"],"keywords":["f-string backslash","SyntaxError","string formatting","escape sequence"],"severity":"moderate","context":"When using escape characters inside f-string expressions","code_snippets":[{"lang":"python","code":"items = ['a', 'b', 'c']\n\n# SyntaxError in Python < 3.12\n# result = f'{chr(92).join(items)}'\n\n# Workaround\nsep = '\\n'\nresult = f'{sep.join(items)}'","description":"Backslash workaround in f-strings"}],"version_info":"Fixed in Python 3.12"},
  {"title":"Shallow copy doesn't copy nested objects","category":"gotcha","tags":["python","copy","shallow","deep","mutable"],"problem":"Using list.copy(), dict.copy(), or copy.copy() only creates a shallow copy. Nested objects (lists within lists, dicts within dicts) are still shared references. Modifying a nested object in the copy modifies the original.","solution":"Use copy.deepcopy() for nested structures:\n\nimport copy\n\noriginal = {'a': [1, 2, 3], 'b': {'x': 1}}\n\n# Shallow — nested objects are shared\nshallow = original.copy()\nshallow['a'].append(4)  # original['a'] is also [1, 2, 3, 4]!\n\n# Deep — everything is independent\ndeep = copy.deepcopy(original)\ndeep['a'].append(5)  # original['a'] unchanged","why":"Shallow copy creates a new container but inserts references to the same child objects. Only the top-level structure is copied; everything inside is shared. Python does this for performance — deep copying can be expensive for large structures.","gotchas":["list[:] and list(original) are also shallow copies","deepcopy can be slow for large nested structures","deepcopy handles circular references correctly","Custom objects need __copy__ and __deepcopy__ for custom behavior"],"language":"python","framework":null,"environment":[],"error_messages":[],"keywords":["shallow copy","deep copy","nested objects","shared reference","copy.deepcopy"],"severity":"major","context":"When duplicating data structures that contain nested mutable objects","code_snippets":[{"lang":"python","code":"import copy\n\n# Shallow: nested list is shared\na = [[1, 2], [3, 4]]\nb = a.copy()\nb[0].append(99)\nprint(a)  # [[1, 2, 99], [3, 4]] — modified!\n\n# Deep: fully independent\nc = copy.deepcopy(a)\nc[0].append(100)\nprint(a)  # [[1, 2, 99], [3, 4]] — unchanged","description":"Shallow vs deep copy"}],"version_info":null},
  {"title":"UnboundLocalError when assigning to variable that exists in outer scope","category":"gotcha","tags":["python","scope","variable","global","nonlocal"],"problem":"Referencing a variable before assigning it in a function raises UnboundLocalError, even if the variable exists in the outer/global scope. Python sees the assignment later in the function and treats it as local for the entire function body.","solution":"Use 'global' or 'nonlocal' keywords:\n\ncount = 0\n\n# For global variables\ndef increment():\n    global count\n    count += 1\n\n# For enclosing function variables\ndef outer():\n    count = 0\n    def inner():\n        nonlocal count\n        count += 1\n    inner()\n\n# Better: avoid mutation, return new values\ndef increment(count):\n    return count + 1","why":"Python determines variable scope at compile time, not runtime. If a variable is assigned anywhere in a function, it's treated as local for the entire function — even lines before the assignment. This is different from JavaScript's hoisting.","gotchas":["global and nonlocal must appear before any use of the variable in the function","Augmented assignment (+=) counts as an assignment","This is determined at compile time — even unreachable assignments affect scope"],"language":"python","framework":null,"environment":[],"error_messages":["UnboundLocalError: local variable 'x' referenced before assignment","UnboundLocalError: cannot access local variable 'x' where it is not associated with a value"],"keywords":["UnboundLocalError","variable scope","global","nonlocal","referenced before assignment"],"severity":"moderate","context":"When trying to modify an outer scope variable inside a function","code_snippets":[{"lang":"python","code":"x = 10\ndef broken():\n    print(x)  # UnboundLocalError!\n    x = 20    # This makes x local for the ENTIRE function\n\ndef fixed():\n    global x\n    print(x)  # 10\n    x = 20","description":"UnboundLocalError scope fix"}],"version_info":null},
  {"title":"Modifying dict or list during iteration causes RuntimeError","category":"gotcha","tags":["python","dict","list","iteration","mutation"],"problem":"Adding or removing items from a dict while iterating raises RuntimeError: dictionary changed size during iteration. Lists don't raise but skip items or produce wrong results.","solution":"Iterate over a copy or collect changes first:\n\n# Dict: iterate over a copy of keys\nfor key in list(d.keys()):\n    if should_remove(key):\n        del d[key]\n\n# Or use dict comprehension\nd = {k: v for k, v in d.items() if not should_remove(k)}\n\n# List: iterate backwards for removal\nfor i in range(len(lst) - 1, -1, -1):\n    if should_remove(lst[i]):\n        del lst[i]\n\n# Or use list comprehension (preferred)\nlst = [x for x in lst if not should_remove(x)]","why":"Python dicts use a hash table internally. Adding/removing keys during iteration invalidates the internal pointer. Lists use an index counter — removing items shifts subsequent items, causing the counter to skip elements.","gotchas":["list(d.keys()) creates a snapshot of keys — safe to iterate","List comprehension creates a new list — doesn't modify in place","For sets, same issue: iterate over set.copy()"],"language":"python","framework":null,"environment":[],"error_messages":["RuntimeError: dictionary changed size during iteration","RuntimeError: Set changed size during iteration"],"keywords":["dict iteration","mutation during loop","RuntimeError","changed size","dictionary comprehension"],"severity":"major","context":"When filtering or modifying collections during iteration","code_snippets":[{"lang":"python","code":"d = {'a': 1, 'b': 2, 'c': 3}\n\n# BAD: RuntimeError\n# for k in d:\n#     if d[k] < 2: del d[k]\n\n# GOOD: iterate copy\nfor k in list(d):\n    if d[k] < 2:\n        del d[k]\n\n# BEST: comprehension\nd = {k: v for k, v in d.items() if v >= 2}","description":"Safe dict modification during iteration"}],"version_info":null},
  {"title":"Float precision: 0.1 + 0.2 != 0.3 in Python","category":"gotcha","tags":["python","float","precision","decimal","math"],"problem":"0.1 + 0.2 == 0.3 returns False in Python (and most languages). This causes bugs in financial calculations, comparisons, and accumulation loops. The actual result is 0.30000000000000004.","solution":"Use the appropriate tool for your precision needs:\n\n# For approximate comparison\nimport math\nmath.isclose(0.1 + 0.2, 0.3)  # True\nmath.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)\n\n# For exact decimal arithmetic (finance)\nfrom decimal import Decimal\nDecimal('0.1') + Decimal('0.2') == Decimal('0.3')  # True\n# IMPORTANT: use strings, not floats: Decimal(0.1) is still imprecise\n\n# For money: use integers (cents)\nprice_cents = 299  # $2.99\ntotal_cents = price_cents * quantity\ntotal_dollars = total_cents / 100","why":"IEEE 754 floating point cannot exactly represent most decimal fractions. 0.1 in binary is a repeating fraction (like 1/3 in decimal). The tiny rounding errors accumulate with arithmetic operations.","gotchas":["Decimal('0.1') is exact but Decimal(0.1) inherits the float imprecision","Never use floats for money — use integer cents or Decimal","math.isclose uses relative tolerance by default — set abs_tol for near-zero comparisons"],"language":"python","framework":null,"environment":[],"error_messages":[],"keywords":["float precision","0.1 + 0.2","decimal arithmetic","IEEE 754","money calculation"],"severity":"major","context":"Any comparison or arithmetic with floating point numbers","code_snippets":[{"lang":"python","code":"# Float comparison\nimport math\nmath.isclose(0.1 + 0.2, 0.3)  # True\n\n# Exact decimal for money\nfrom decimal import Decimal\ntotal = Decimal('19.99') + Decimal('4.99')  # Decimal('24.98') exactly\n\n# Integer cents (simplest for money)\nprice = 1999  # $19.99 in cents","description":"Handling float precision"}],"version_info":null},
  {"title":"asyncio.run() cannot be called from a running event loop","category":"gotcha","tags":["python","asyncio","event-loop","async","jupyter"],"problem":"Calling asyncio.run() inside Jupyter notebooks, or from code already running in an async context raises RuntimeError: This event loop is already running. This also happens in some frameworks like FastAPI background tasks.","solution":"Use different approaches depending on context:\n\n# In Jupyter notebooks\nawait my_coroutine()  # Just await directly — Jupyter has a running loop\n\n# Or use nest_asyncio\nimport nest_asyncio\nnest_asyncio.apply()\nasyncio.run(my_coroutine())  # Now works\n\n# In already-async code, just await\nasync def handler():\n    result = await my_coroutine()  # Don't use asyncio.run()\n\n# If you need sync-to-async bridge\nimport asyncio\nloop = asyncio.get_event_loop()\nresult = loop.run_until_complete(my_coroutine())","why":"asyncio.run() creates a new event loop and runs until the coroutine completes. But there can only be one event loop per thread. Jupyter, some web frameworks, and other async contexts already have a running loop.","gotchas":["nest_asyncio patches the loop to allow nesting — useful for Jupyter but can hide bugs","In Python 3.10+, asyncio.run() creates and sets a new event loop","loop.run_until_complete() is deprecated in favor of asyncio.run() but still works for bridging"],"language":"python","framework":null,"environment":["jupyter"],"error_messages":["RuntimeError: This event loop is already running","RuntimeError: asyncio.run() cannot be called from a running event loop"],"keywords":["asyncio.run","event loop running","Jupyter async","nest_asyncio","RuntimeError"],"severity":"major","context":"When using asyncio.run() in Jupyter or within an already-async context","code_snippets":[{"lang":"python","code":"# In Jupyter: just await\nresult = await fetch_data()\n\n# If you must use asyncio.run:\nimport nest_asyncio\nnest_asyncio.apply()\nresult = asyncio.run(fetch_data())","description":"Async in Jupyter / nested event loops"}],"version_info":"Python 3.7+ for asyncio.run()"},
  {"title":"subprocess.run with shell=True is a security risk","category":"gotcha","tags":["python","subprocess","security","shell-injection","command"],"problem":"Using subprocess.run(cmd, shell=True) with user input enables shell injection attacks. An attacker can append commands with ; or && to execute arbitrary code on the system.","solution":"Never use shell=True with user input. Pass arguments as a list:\n\n# BAD — shell injection risk\nsubprocess.run(f'grep {user_input} file.txt', shell=True)\n\n# GOOD — arguments are escaped automatically\nsubprocess.run(['grep', user_input, 'file.txt'])\n\n# If you need shell features (pipes, globbing):\nimport shlex\nsubprocess.run(shlex.split(f'grep {shlex.quote(user_input)} file.txt'), shell=False)\n\n# For pipes without shell=True:\nfrom subprocess import Popen, PIPE\np1 = Popen(['cat', 'file.txt'], stdout=PIPE)\np2 = Popen(['grep', 'pattern'], stdin=p1.stdout, stdout=PIPE)\noutput = p2.communicate()[0]","why":"shell=True passes the command string to /bin/sh, which interprets shell metacharacters. Input like 'file.txt; rm -rf /' would execute both commands. Without shell=True, arguments are passed directly to the executable without shell interpretation.","gotchas":["shlex.quote() escapes shell metacharacters if you must use shell=True","On Windows, shell=True uses cmd.exe which has different escaping rules","subprocess.run without shell=True requires the command as a list, not a string"],"language":"python","framework":null,"environment":[],"error_messages":["FileNotFoundError: [Errno 2] No such file or directory","OSError: [Errno 8] Exec format error"],"keywords":["shell injection","subprocess security","shell=True","command injection","shlex"],"severity":"critical","context":"When executing system commands with any user-provided input","code_snippets":[{"lang":"python","code":"import subprocess, shlex\n\nuser_input = 'pattern'\n\n# SAFE: list arguments\nsubprocess.run(['grep', '-r', user_input, '.'])\n\n# SAFE: shlex.quote for shell=True\nsubprocess.run(f'grep -r {shlex.quote(user_input)} .', shell=True)","description":"Safe subprocess usage"}],"version_info":null},
  {"title":"json.dumps fails on datetime and other non-serializable types","category":"gotcha","tags":["python","json","serialization","datetime","custom-encoder"],"problem":"json.dumps() raises TypeError: Object of type datetime is not JSON serializable. This happens with datetime, Decimal, set, bytes, UUID, and any custom objects.","solution":"Use a custom encoder or default function:\n\nimport json\nfrom datetime import datetime\nfrom decimal import Decimal\n\ndef json_default(obj):\n    if isinstance(obj, datetime):\n        return obj.isoformat()\n    if isinstance(obj, Decimal):\n        return str(obj)\n    if isinstance(obj, set):\n        return list(obj)\n    if isinstance(obj, bytes):\n        return obj.decode('utf-8')\n    raise TypeError(f'Not serializable: {type(obj)}')\n\njson.dumps(data, default=json_default)\n\n# Or use a class-based encoder\nclass CustomEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, datetime):\n            return obj.isoformat()\n        return super().default(obj)","why":"JSON only supports strings, numbers, booleans, null, arrays, and objects. Python's json module doesn't know how to convert other types. You must provide the conversion logic.","gotchas":["Use str() for Decimal to avoid float precision issues","datetime.isoformat() includes timezone info if the datetime is aware","The default function is only called for non-serializable types — it doesn't see strings or ints"],"language":"python","framework":null,"environment":[],"error_messages":["TypeError: Object of type datetime is not JSON serializable","TypeError: Object of type Decimal is not JSON serializable","TypeError: Object of type set is not JSON serializable","TypeError: Object of type bytes is not JSON serializable"],"keywords":["json serialize","datetime JSON","custom encoder","TypeError serializable","json.dumps"],"severity":"moderate","context":"When serializing Python objects to JSON that contain non-standard types","code_snippets":[{"lang":"python","code":"import json\nfrom datetime import datetime\n\ndata = {'created': datetime.now(), 'tags': {'a', 'b'}}\n\n# Custom default handler\njson.dumps(data, default=str)  # Quick fix: convert everything to string\n\n# Better: type-specific handler\ndef handler(obj):\n    if isinstance(obj, datetime): return obj.isoformat()\n    if isinstance(obj, set): return list(obj)\n    raise TypeError\n\njson.dumps(data, default=handler)","description":"JSON serialization of custom types"}],"version_info":null},
  {"title":"logging.basicConfig() only works on first call","category":"gotcha","tags":["python","logging","configuration","debug"],"problem":"Calling logging.basicConfig() multiple times has no effect after the first call. Imported libraries may call it before your code runs, causing your configuration to be silently ignored.","solution":"Use logging.getLogger() and configure handlers explicitly:\n\nimport logging\n\n# Don't rely on basicConfig in libraries\nlogger = logging.getLogger(__name__)\n\n# Explicit handler configuration (always works)\nhandler = logging.StreamHandler()\nhandler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))\nlogger.addHandler(handler)\nlogger.setLevel(logging.DEBUG)\n\n# Or force basicConfig to reconfigure\nlogging.basicConfig(level=logging.DEBUG, force=True)  # Python 3.8+","why":"basicConfig() checks if the root logger already has handlers. If any handler exists (from a library import or previous call), it does nothing. This is a common source of 'why aren't my logs showing?' bugs.","gotchas":["force=True parameter was added in Python 3.8","Libraries should use getLogger(__name__) and never call basicConfig","The root logger propagates to all child loggers by default"],"language":"python","framework":null,"environment":[],"error_messages":[],"keywords":["logging basicConfig","logging not working","log configuration","getLogger","force basicConfig"],"severity":"moderate","context":"When configuring Python logging, especially in applications that import third-party libraries","code_snippets":[{"lang":"python","code":"import logging\n\n# UNRELIABLE (may be ignored):\nlogging.basicConfig(level=logging.DEBUG)\n\n# RELIABLE:\nlogging.basicConfig(level=logging.DEBUG, force=True)  # 3.8+\n\n# MOST RELIABLE:\nlogger = logging.getLogger('myapp')\nlogger.setLevel(logging.DEBUG)\nif not logger.handlers:\n    handler = logging.StreamHandler()\n    handler.setFormatter(logging.Formatter('%(levelname)s: %(message)s'))\n    logger.addHandler(handler)","description":"Reliable logging configuration"}],"version_info":"force= parameter requires Python 3.8+"},
  {"title":"pytest fixture not found even though it's defined","category":"gotcha","tags":["python","pytest","fixtures","conftest","testing"],"problem":"pytest raises ERRORS or fixture 'x' not found even though the fixture is defined in another test file. Fixtures defined in regular test files are not shared across files.","solution":"Move shared fixtures to conftest.py:\n\n# conftest.py (auto-discovered by pytest)\nimport pytest\n\n@pytest.fixture\ndef db_connection():\n    conn = create_connection()\n    yield conn\n    conn.close()\n\n@pytest.fixture\ndef sample_user(db_connection):\n    user = create_user(db_connection)\n    yield user\n    delete_user(db_connection, user.id)\n\n# conftest.py files can exist at any directory level\n# Fixtures are available to all tests in that directory and subdirectories","why":"pytest only auto-discovers fixtures from conftest.py files. Fixtures in regular test_*.py files are only visible within that file. conftest.py is a special filename that pytest imports automatically.","gotchas":["conftest.py must be named exactly 'conftest.py' — no other names work","You can have conftest.py at every directory level — they stack","Fixtures in conftest.py should not be imported manually — pytest handles it","scope='session' fixtures run once per test session, not once per file"],"language":"python","framework":"pytest","environment":[],"error_messages":["ERRORS","fixture 'x' not found"],"keywords":["pytest fixture","conftest.py","fixture not found","shared fixtures","test setup"],"severity":"moderate","context":"When sharing pytest fixtures across multiple test files","code_snippets":[{"lang":"python","code":"# tests/conftest.py — shared fixtures\nimport pytest\n\n@pytest.fixture\ndef client(app):\n    return app.test_client()\n\n@pytest.fixture(scope='session')\ndef db():\n    engine = create_engine('sqlite://')\n    yield engine\n    engine.dispose()","description":"Shared fixtures in conftest.py"}],"version_info":null},
  {"title":"async/await in Array.forEach doesn't work","category":"gotcha","tags":["javascript","async","await","forEach","iteration"],"problem":"Using async/await inside Array.forEach() doesn't wait for the promises. forEach ignores the return value of its callback, so await inside it does nothing useful — all iterations fire simultaneously and the code after forEach runs before they complete.","solution":"Use for...of loop for sequential execution:\n\n// Sequential — one at a time\nfor (const item of items) {\n  await processItem(item);\n}\n\n// Parallel — all at once, wait for all\nawait Promise.all(items.map(item => processItem(item)));\n\n// Parallel with concurrency limit\nasync function mapLimit(items, limit, fn) {\n  const results = [];\n  const executing = new Set();\n  for (const item of items) {\n    const p = fn(item).then(r => { executing.delete(p); return r; });\n    executing.add(p);\n    results.push(p);\n    if (executing.size >= limit) await Promise.race(executing);\n  }\n  return Promise.all(results);\n}","why":"forEach is a synchronous function that calls its callback for each element. It doesn't know about Promises or async functions. Even though the callback is async, forEach doesn't await its return value — it just calls it and moves on.","gotchas":["for...of is sequential — each iteration waits for the previous","Promise.all runs all in parallel — faster but may overload APIs","map() returns an array of Promises which Promise.all can handle","reduce with await can also be used but is harder to read"],"language":"javascript","framework":null,"environment":[],"error_messages":[],"keywords":["async forEach","await in loop","Promise.all","sequential async","parallel async","for of"],"severity":"major","context":"When performing async operations on each item in an array","code_snippets":[{"lang":"javascript","code":"const items = [1, 2, 3];\n\n// BAD: doesn't wait\nitems.forEach(async (item) => {\n  await doSomething(item); // fires all at once!\n});\nconsole.log('done'); // runs BEFORE any doSomething finishes\n\n// GOOD: sequential\nfor (const item of items) {\n  await doSomething(item);\n}\nconsole.log('done'); // runs AFTER all complete","description":"async/await with arrays"}],"version_info":null},
  {"title":"typeof null === 'object' in JavaScript","category":"gotcha","tags":["javascript","typeof","null","type-checking","bug"],"problem":"typeof null returns 'object' instead of 'null'. This causes bugs when checking if a value is an object: typeof x === 'object' is true for null. This is a well-known JavaScript bug that can never be fixed for backwards compatibility.","solution":"Always check for null explicitly:\n\n// BAD: null passes this check\nif (typeof x === 'object') { /* x could be null! */ }\n\n// GOOD: exclude null\nif (x !== null && typeof x === 'object') { /* x is a real object */ }\n\n// BEST: use a helper\nfunction isObject(x) {\n  return x !== null && typeof x === 'object';\n}\n\n// For checking 'is this a plain object':\nfunction isPlainObject(x) {\n  return Object.prototype.toString.call(x) === '[object Object]';\n}","why":"This is a bug from JavaScript's first implementation in 1995. Values were stored as a type tag + value, and null was represented as the NULL pointer (0x00). The type tag for objects was also 0. So typeof null checked the type tag and saw 'object'. It can't be fixed because too much existing code depends on this behavior.","gotchas":["typeof undefined === 'undefined' works correctly","typeof NaN === 'number' is another surprising one","Array.isArray() is the reliable way to check for arrays, not typeof"],"language":"javascript","framework":null,"environment":[],"error_messages":["TypeError: Cannot read properties of null"],"keywords":["typeof null","type checking","null check","object null","JavaScript bug"],"severity":"moderate","context":"When type-checking values in JavaScript","code_snippets":[{"lang":"javascript","code":"typeof null      // 'object' (bug)\ntypeof undefined // 'undefined'\ntypeof 42        // 'number'\ntypeof 'hi'      // 'string'\ntypeof true      // 'boolean'\ntypeof Symbol()  // 'symbol'\ntypeof {}        // 'object'\ntypeof []        // 'object' (use Array.isArray)","description":"typeof quirks"}],"version_info":null},
  {"title":"Array.sort() mutates in place and sorts as strings by default","category":"gotcha","tags":["javascript","array","sort","mutation","comparison"],"problem":"Array.sort() modifies the original array AND sorts elements as strings by default. [10, 9, 2, 1].sort() returns [1, 10, 2, 9] because '10' comes before '2' alphabetically.","solution":"Always provide a compare function, and use toSorted() to avoid mutation:\n\nconst nums = [10, 9, 2, 1];\n\n// BAD: sorts as strings, mutates original\nnums.sort();  // [1, 10, 2, 9]\n\n// GOOD: numeric sort\nnums.sort((a, b) => a - b);  // [1, 2, 9, 10]\n\n// BEST: non-mutating (ES2023)\nconst sorted = nums.toSorted((a, b) => a - b);  // nums unchanged\n\n// String sort (case-insensitive)\nnames.sort((a, b) => a.localeCompare(b));\n\n// Sort by object property\nusers.sort((a, b) => a.age - b.age);","why":"JavaScript's sort() converts elements to strings and compares their UTF-16 code unit sequences. This is useful for string arrays but completely wrong for numbers. The mutation is also surprising — most array methods (map, filter) return new arrays.","gotchas":["toSorted() is ES2023 — check browser/Node support","sort() is not stable in all engines before ES2019","The compare function should return negative, zero, or positive — not boolean","reverse() also mutates — use toReversed() for non-mutating"],"language":"javascript","framework":null,"environment":[],"error_messages":[],"keywords":["array sort","sort mutates","string sort","numeric sort","toSorted","compare function"],"severity":"major","context":"When sorting arrays in JavaScript, especially numbers","code_snippets":[{"lang":"javascript","code":"// String sort (default)\n[10, 9, 2].sort()       // [10, 2, 9] — WRONG for numbers!\n\n// Numeric sort\n[10, 9, 2].sort((a, b) => a - b)  // [2, 9, 10]\n\n// Non-mutating (ES2023)\n[10, 9, 2].toSorted((a, b) => a - b)  // [2, 9, 10]","description":"Proper array sorting"}],"version_info":"toSorted() requires ES2023 / Node 20+"},
  {"title":"'this' binding lost in callbacks and event handlers","category":"gotcha","tags":["javascript","this","binding","callbacks","arrow-functions"],"problem":"When passing a method as a callback, 'this' becomes undefined (strict mode) or the global object. obj.method works, but setTimeout(obj.method, 100) loses the 'this' context.","solution":"Three fixes:\n\n// 1. Arrow function (most common)\nsetTimeout(() => obj.method(), 100);\nbutton.addEventListener('click', () => this.handleClick());\n\n// 2. bind()\nsetTimeout(obj.method.bind(obj), 100);\n\n// 3. In classes, use arrow function properties\nclass MyComponent {\n  handleClick = () => {\n    console.log(this);  // always the instance\n  };\n}\n\n// 4. In React class components\nconstructor() {\n  this.handleClick = this.handleClick.bind(this);\n}","why":"In JavaScript, 'this' is determined by HOW a function is called, not where it's defined. When you pass obj.method as a callback, you're passing the function reference without the object context. Arrow functions capture 'this' from the enclosing scope.","gotchas":["Arrow functions cannot be used as constructors (no new keyword)","bind() creates a new function — calling it multiple times creates multiple copies","In DOM event handlers, 'this' refers to the element unless you use arrow functions","Arrow class properties create a new function per instance — not on the prototype"],"language":"javascript","framework":null,"environment":[],"error_messages":["TypeError: Cannot read properties of undefined","TypeError: this.setState is not a function"],"keywords":["this binding","lost context","arrow function","bind","callback this"],"severity":"major","context":"When passing methods as callbacks to setTimeout, event listeners, or array methods","code_snippets":[{"lang":"javascript","code":"class Timer {\n  count = 0;\n\n  // BAD: 'this' lost in setTimeout\n  start() {\n    setInterval(function() {\n      this.count++;  // TypeError!\n    }, 1000);\n  }\n\n  // GOOD: arrow function preserves 'this'\n  start() {\n    setInterval(() => {\n      this.count++;  // works!\n    }, 1000);\n  }\n}","description":"Preserving this in callbacks"}],"version_info":null},
  {"title":"Closure variable in for loop captures final value","category":"gotcha","tags":["javascript","closure","loop","var","let","scope"],"problem":"Using var in a for loop and referencing the variable in a closure (setTimeout, event handler) captures the same variable — all closures see the final value. Classic interview question.","solution":"Use let instead of var — it creates a new binding per iteration:\n\n// BAD: var — all closures share one variable\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);  // prints 3, 3, 3\n}\n\n// GOOD: let — each iteration gets its own i\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);  // prints 0, 1, 2\n}\n\n// ALT: IIFE (pre-ES6 solution)\nfor (var i = 0; i < 3; i++) {\n  (function(j) {\n    setTimeout(() => console.log(j), 100);\n  })(i);\n}","why":"var is function-scoped, not block-scoped. The for loop has one 'i' variable that all closures reference. By the time the closures execute, the loop has finished and i equals 3. let is block-scoped — each iteration creates a new variable.","gotchas":["This only matters when closures outlive the loop iteration (async, callbacks)","const in for...of loops also creates a new binding per iteration","forEach naturally avoids this because its callback gets the value as a parameter"],"language":"javascript","framework":null,"environment":[],"error_messages":[],"keywords":["closure loop","var vs let","loop variable","setTimeout loop","block scope"],"severity":"major","context":"When using closures inside loops, especially with setTimeout or event handlers","code_snippets":[{"lang":"javascript","code":"// The classic gotcha\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 10);\n}\n// Output: 3, 3, 3\n\n// The fix: use let\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 10);\n}\n// Output: 0, 1, 2","description":"Closure in loop fix"}],"version_info":null},
  {"title":"Promise.all rejects on first failure, losing other results","category":"gotcha","tags":["javascript","promises","async","error-handling","concurrency"],"problem":"Promise.all() rejects immediately when ANY promise rejects, discarding results from promises that succeeded. If you're fetching data from 5 APIs and one fails, you lose all 5 results.","solution":"Use Promise.allSettled() to get all results regardless of success/failure:\n\nconst results = await Promise.allSettled([\n  fetch('/api/users'),\n  fetch('/api/posts'),\n  fetch('/api/comments'),\n]);\n\n// Each result has { status: 'fulfilled', value } or { status: 'rejected', reason }\nconst successes = results.filter(r => r.status === 'fulfilled').map(r => r.value);\nconst failures = results.filter(r => r.status === 'rejected').map(r => r.reason);\n\n// Or use Promise.all with individual .catch\nconst results = await Promise.all([\n  fetch('/api/users').catch(e => ({ error: e })),\n  fetch('/api/posts').catch(e => ({ error: e })),\n]);","why":"Promise.all is designed for the 'all or nothing' case where every promise must succeed. allSettled (ES2020) handles the 'give me whatever you can' case. The individual .catch pattern works in older environments.","gotchas":["Promise.allSettled() returns an array of result objects, not values directly","Promise.any() resolves with the first success (opposite of all)","Promise.race() resolves/rejects with the first settled promise"],"language":"javascript","framework":null,"environment":[],"error_messages":["Unhandled promise rejection"],"keywords":["Promise.all","Promise.allSettled","parallel promises","error handling","concurrent requests"],"severity":"major","context":"When running multiple async operations in parallel where partial failure is acceptable","code_snippets":[{"lang":"javascript","code":"// Promise.all — fails fast\ntry {\n  const [a, b, c] = await Promise.all([p1, p2, p3]);\n} catch (e) {\n  // ONE failed — you lost a, b, c\n}\n\n// Promise.allSettled — always completes\nconst results = await Promise.allSettled([p1, p2, p3]);\n// results[0].status === 'fulfilled' | 'rejected'","description":"Promise.all vs allSettled"}],"version_info":"Promise.allSettled requires ES2020"},
  {"title":"NaN is not equal to itself in JavaScript","category":"gotcha","tags":["javascript","NaN","comparison","number","type-checking"],"problem":"NaN !== NaN returns true. This means you can't check for NaN with equality operators. Also, typeof NaN === 'number', and NaN is the result of invalid math operations like 0/0 or parseInt('abc').","solution":"Use Number.isNaN() (not the global isNaN):\n\n// BAD: global isNaN coerces to number first\nisNaN('hello')     // true (coerces to NaN)\nisNaN(undefined)   // true\n\n// GOOD: Number.isNaN checks type AND value\nNumber.isNaN(NaN)       // true\nNumber.isNaN('hello')   // false\nNumber.isNaN(undefined) // false\n\n// Self-comparison trick\nfunction isNaN(x) { return x !== x; }  // only NaN is not equal to itself\n\n// Also useful\nNumber.isFinite(x)  // false for NaN, Infinity, -Infinity","why":"IEEE 754 defines NaN as not equal to anything, including itself. This is because NaN represents 'the result of an undefined operation' — there are many ways to get NaN, and two NaN values don't necessarily represent the same failed operation.","gotchas":["Global isNaN() coerces its argument to Number first — use Number.isNaN()","Array.includes(NaN) returns true (uses SameValueZero), but indexOf(NaN) returns -1 (uses ===)","JSON.stringify(NaN) produces 'null', not 'NaN'"],"language":"javascript","framework":null,"environment":[],"error_messages":[],"keywords":["NaN comparison","Number.isNaN","not a number","NaN check","isNaN global"],"severity":"moderate","context":"When checking for NaN values in JavaScript","code_snippets":[{"lang":"javascript","code":"NaN === NaN      // false\nNaN !== NaN      // true\n\n// Global isNaN is broken\nisNaN('hello')        // true (!) — coerces to Number\n\n// Number.isNaN is correct\nNumber.isNaN('hello') // false\nNumber.isNaN(NaN)     // true\nNumber.isNaN(0 / 0)   // true","description":"NaN checking"}],"version_info":null},
  {"title":"Object.keys() returns strings even for numeric keys","category":"gotcha","tags":["javascript","object","keys","type-coercion","map"],"problem":"Object.keys() always returns an array of strings, even when the object has numeric keys. const obj = {1: 'a', 2: 'b'}; Object.keys(obj) returns ['1', '2'] not [1, 2]. This causes comparison bugs.","solution":"Convert keys to numbers if needed, or use Map for numeric keys:\n\n// Convert to numbers\nconst numKeys = Object.keys(obj).map(Number);\n\n// Use Map for proper key types\nconst map = new Map();\nmap.set(1, 'a');\nmap.set(2, 'b');\n[...map.keys()]  // [1, 2] — actual numbers\n\n// For iteration with numeric keys\nfor (const [key, value] of Object.entries(obj)) {\n  const numKey = Number(key);\n  // use numKey\n}","why":"JavaScript object keys are always strings (or Symbols). When you write {1: 'a'}, the key 1 is coerced to the string '1'. This is a fundamental language design choice. Map preserves key types.","gotchas":["for...in also yields string keys","JSON.parse preserves numeric keys as strings","Map is the correct data structure when key types matter","Object.keys order: integer-like keys sorted numerically first, then string keys in insertion order"],"language":"javascript","framework":null,"environment":[],"error_messages":[],"keywords":["Object.keys","string keys","numeric keys","Map vs Object","key types"],"severity":"moderate","context":"When working with objects that have numeric keys","code_snippets":[{"lang":"javascript","code":"const obj = { 1: 'a', 2: 'b', foo: 'c' };\nObject.keys(obj)  // ['1', '2', 'foo'] — all strings\n\n// Use Map for typed keys\nconst m = new Map([[1, 'a'], [2, 'b']]);\n[...m.keys()]  // [1, 2] — actual numbers","description":"Object keys are always strings"}],"version_info":null},
  {"title":"ESM import requires file extensions in Node.js","category":"gotcha","tags":["javascript","nodejs","esm","commonjs","modules","imports"],"problem":"Node.js ESM (import/export) requires file extensions in import paths. import { foo } from './utils' fails with ERR_MODULE_NOT_FOUND — you must write './utils.js'. This is different from CommonJS require() and bundlers like webpack.","solution":"Always include the file extension in ESM imports:\n\n// BAD in Node ESM\nimport { foo } from './utils';      // ERR_MODULE_NOT_FOUND\n\n// GOOD\nimport { foo } from './utils.js';   // works\nimport data from './data.json' assert { type: 'json' };  // JSON needs assertion\n\n// To enable ESM in Node:\n// Option 1: Add \"type\": \"module\" in package.json\n// Option 2: Use .mjs extension\n\n// For TypeScript: import from .js even though source is .ts\nimport { foo } from './utils.js';  // TypeScript resolves to utils.ts","why":"Node.js ESM follows the browser ESM spec, which requires explicit file extensions. CommonJS had special resolution logic (try .js, .json, .node, index.js) but ESM intentionally doesn't — it's explicit by design. Bundlers like webpack add their own resolution.","gotchas":["TypeScript ESM: import from './file.js' even though the source file is .ts","Directory imports (import './dir') don't work in ESM — need './dir/index.js'","require() still works in CommonJS files alongside ESM","JSON imports need 'assert { type: \"json\" }' in Node ESM"],"language":"javascript","framework":null,"environment":["nodejs"],"error_messages":["ERR_MODULE_NOT_FOUND","Cannot find module","ERR_UNKNOWN_FILE_EXTENSION"],"keywords":["ESM imports","file extension","ERR_MODULE_NOT_FOUND","CommonJS vs ESM","type module"],"severity":"major","context":"When migrating from CommonJS to ESM in Node.js projects","code_snippets":[{"lang":"javascript","code":"// package.json\n{ \"type\": \"module\" }\n\n// ESM requires extensions\nimport express from 'express';        // packages work without extension\nimport { helper } from './lib.js';    // local files NEED .js\nimport config from './cfg.json' assert { type: 'json' };","description":"ESM imports in Node.js"}],"version_info":"Node.js 14+ for ESM, 18+ for stable JSON import assertions"},
  {"title":"TypeScript any vs unknown: use unknown for type-safe handling","category":"pattern","tags":["typescript","types","any","unknown","type-safety"],"problem":"Using 'any' disables all type checking — you can call methods, access properties, and pass it anywhere without errors. This defeats the purpose of TypeScript and hides bugs that only appear at runtime.","solution":"Use 'unknown' instead of 'any' for values with uncertain types:\n\n// BAD: any disables type checking\nfunction process(data: any) {\n  data.foo.bar.baz();  // no error — crashes at runtime\n}\n\n// GOOD: unknown requires type narrowing\nfunction process(data: unknown) {\n  // data.foo;  // Error: Object is of type 'unknown'\n  \n  if (typeof data === 'string') {\n    data.toUpperCase();  // OK — narrowed to string\n  }\n  if (data !== null && typeof data === 'object' && 'foo' in data) {\n    // narrowed to object with 'foo'\n  }\n}\n\n// With type guards\nfunction isUser(x: unknown): x is User {\n  return typeof x === 'object' && x !== null && 'id' in x && 'name' in x;\n}","why":"'any' opts out of the type system entirely — it's assignable to and from everything. 'unknown' is the type-safe counterpart: it accepts any value but forces you to narrow the type before using it. Use 'any' only as a last resort during migration.","gotchas":["unknown is NOT assignable to other types without narrowing — that's the point","JSON.parse returns 'any' — consider wrapping with validation (zod, io-ts)","catch (e) types e as 'unknown' in strict mode — narrow with instanceof Error"],"language":"typescript","framework":null,"environment":[],"error_messages":["Object is of type 'unknown'"],"keywords":["any vs unknown","type safety","type narrowing","type guard","unknown type"],"severity":"major","context":"When handling values of uncertain types in TypeScript","code_snippets":[{"lang":"typescript","code":"// Type guard function\nfunction isError(x: unknown): x is Error {\n  return x instanceof Error;\n}\n\ntry {\n  riskyOperation();\n} catch (e: unknown) {\n  if (isError(e)) {\n    console.error(e.message);  // safe\n  }\n}","description":"Type-safe error handling with unknown"}],"version_info":"TypeScript 3.0+ for unknown"},
  {"title":"TypeScript enums have surprising runtime behavior","category":"gotcha","tags":["typescript","enums","const-enum","union-type"],"problem":"TypeScript numeric enums generate runtime JavaScript objects with reverse mappings. This increases bundle size and allows invalid values. enum Status { Active = 0, Inactive = 1 } allows Status[99] with no error.","solution":"Prefer const enums or union types:\n\n// Union type (no runtime overhead)\ntype Status = 'active' | 'inactive';\n\n// Const enum (inlined at compile time, no runtime object)\nconst enum Direction { Up, Down, Left, Right }\n// Compiles to: const d = 0; (no Direction object)\n\n// If you need runtime iteration, use 'as const' object\nconst STATUS = { Active: 'active', Inactive: 'inactive' } as const;\ntype Status = typeof STATUS[keyof typeof STATUS];  // 'active' | 'inactive'\nObject.values(STATUS);  // ['active', 'inactive']","why":"Numeric enums compile to a bidirectional object: { 0: 'Active', Active: 0 }. This reverse mapping allows Status[0] === 'Active', but it also means the full object exists at runtime. String enums don't have reverse mapping. Union types have zero runtime cost.","gotchas":["const enum is erased at compile time — can't use Object.values() on it","String enums don't have reverse mapping and are safer than numeric","isolatedModules (used by babel/esbuild) forbids const enum across files","Union types work with exhaustive switch checks (never type)"],"language":"typescript","framework":null,"environment":[],"error_messages":[],"keywords":["enum runtime","const enum","union type","string literal","as const"],"severity":"moderate","context":"When choosing between enums and union types in TypeScript","code_snippets":[{"lang":"typescript","code":"// Prefer union types\ntype Color = 'red' | 'green' | 'blue';\n\n// Or const object for runtime access\nconst Color = { Red: 'red', Green: 'green', Blue: 'blue' } as const;\ntype Color = typeof Color[keyof typeof Color];","description":"Alternatives to enums"}],"version_info":null},
  {"title":"JSON.stringify silently drops undefined, functions, and symbols","category":"gotcha","tags":["javascript","json","stringify","serialization","data-loss"],"problem":"JSON.stringify() silently removes properties with undefined values, function values, and Symbol values. It also converts NaN and Infinity to null. This causes silent data loss when serializing objects.","solution":"Be aware of what's dropped and handle it:\n\nconst obj = {\n  a: 1,\n  b: undefined,    // DROPPED\n  c: function(){},  // DROPPED\n  d: Symbol(),      // DROPPED\n  e: NaN,           // becomes null\n  f: Infinity,      // becomes null\n};\n\nJSON.stringify(obj)  // {\"a\":1,\"e\":null,\"f\":null}\n\n// Use a replacer to preserve values\nJSON.stringify(obj, (key, value) => {\n  if (value === undefined) return '__undefined__';\n  if (typeof value === 'function') return '__function__';\n  if (Number.isNaN(value)) return '__NaN__';\n  return value;\n});\n\n// For Maps/Sets, convert first\nconst mapObj = Object.fromEntries(myMap);\nconst setArr = [...mySet];","why":"JSON is a data interchange format that only supports strings, numbers, booleans, null, objects, and arrays. JavaScript has more types, so the extra ones are either dropped (undefined, functions, symbols) or converted to the closest JSON equivalent (NaN→null).","gotchas":["In arrays, undefined becomes null (not removed): [1, undefined, 3] → [1, null, 3]","toJSON() method on objects is called automatically by JSON.stringify","BigInt throws TypeError — it's not silently converted","Circular references throw TypeError — use a replacer to handle them"],"language":"javascript","framework":null,"environment":[],"error_messages":["TypeError: Do not know how to serialize a BigInt","TypeError: Converting circular structure to JSON"],"keywords":["JSON.stringify","undefined dropped","data loss","serialization","NaN null"],"severity":"major","context":"When serializing JavaScript objects to JSON for storage or transmission","code_snippets":[{"lang":"javascript","code":"const data = { a: 1, b: undefined, c: NaN };\nJSON.stringify(data)  // '{\"a\":1,\"c\":null}' — b is GONE\n\n// In arrays: undefined → null\nJSON.stringify([1, undefined, 3])  // '[1,null,3]'","description":"JSON.stringify data loss"}],"version_info":null},
  {"title":"Spread operator creates shallow copies only","category":"gotcha","tags":["javascript","spread","shallow-copy","deep-copy","structuredClone"],"problem":"The spread operator ({...obj} or [...arr]) only creates a shallow copy. Nested objects/arrays are still shared references. Modifying nested data in the copy also modifies the original.","solution":"Use structuredClone() for deep copies (modern), or JSON parse/stringify (older):\n\nconst original = { a: 1, nested: { b: 2 } };\n\n// Shallow — nested is shared\nconst shallow = { ...original };\nshallow.nested.b = 99;  // original.nested.b is also 99!\n\n// Deep copy (modern, recommended)\nconst deep = structuredClone(original);\ndeep.nested.b = 99;  // original unchanged\n\n// JSON trick (older, has limitations)\nconst deep2 = JSON.parse(JSON.stringify(original));\n\n// For specific updates, use immutable update pattern\nconst updated = {\n  ...original,\n  nested: { ...original.nested, b: 99 }\n};","why":"Spread creates a new object and copies own enumerable properties. For primitive values, this creates independent copies. For object/array values, it copies the reference, not the contents.","gotchas":["structuredClone doesn't copy functions, DOM nodes, or Error objects","JSON.parse/stringify drops undefined, functions, Dates (become strings), and Symbols","structuredClone handles circular references; JSON method throws","For React state, the immutable update pattern (spread at each level) is preferred"],"language":"javascript","framework":null,"environment":[],"error_messages":["DOMException: Failed to execute 'structuredClone'"],"keywords":["shallow copy","deep copy","structuredClone","spread operator","nested copy","immutable update"],"severity":"major","context":"When copying objects or arrays that contain nested structures","code_snippets":[{"lang":"javascript","code":"const obj = { a: { b: 1 } };\n\n// Shallow (shared nested)\nconst s = { ...obj };\ns.a.b = 2;  // obj.a.b is also 2!\n\n// Deep (independent)\nconst d = structuredClone(obj);\nd.a.b = 3;  // obj.a.b still 2","description":"Shallow vs deep copy in JS"}],"version_info":"structuredClone available in Node 17+, all modern browsers"}
]