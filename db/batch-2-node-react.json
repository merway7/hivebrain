[
  {"title":"EMFILE: too many open files when processing directories","category":"debug","tags":["nodejs","file-system","EMFILE","ulimit"],"problem":"Processing many files concurrently with fs.readFile or fs.open causes Error: EMFILE, too many open files. The OS has a per-process file descriptor limit (usually 1024 on Linux/macOS).","solution":"Limit concurrent file operations:\n\n// Option 1: Use graceful-fs (drop-in replacement)\nconst fs = require('graceful-fs');\n\n// Option 2: Limit concurrency manually\nasync function processFiles(files, limit = 50) {\n  const results = [];\n  for (let i = 0; i < files.length; i += limit) {\n    const batch = files.slice(i, i + limit);\n    const batchResults = await Promise.all(batch.map(f => fs.promises.readFile(f)));\n    results.push(...batchResults);\n  }\n  return results;\n}\n\n// Option 3: Increase OS limit\n// macOS: ulimit -n 10240\n// Linux: edit /etc/security/limits.conf","why":"Each open file uses a file descriptor. The OS limits these per process to prevent resource exhaustion. Node.js async I/O opens many files simultaneously without waiting for previous ones to close.","gotchas":["ulimit changes are per-shell session — make them permanent in .bashrc/.zshrc","graceful-fs queues open calls and retries on EMFILE","fs.promises API still has the same limit — it's an OS constraint","macOS default is 256 soft limit, Linux is 1024"],"language":"javascript","framework":null,"environment":["nodejs"],"error_messages":["Error: EMFILE, too many open files","Error: EMFILE: too many open files, open"],"keywords":["EMFILE","too many open files","file descriptor","ulimit","graceful-fs","concurrent files"],"severity":"major","context":"When reading, writing, or watching many files concurrently in Node.js","code_snippets":[{"lang":"javascript","code":"// Use graceful-fs as drop-in replacement\nconst fs = require('graceful-fs');\n// It queues file operations to avoid EMFILE","description":"graceful-fs fix"}],"version_info":null},
  {"title":"EADDRINUSE: port already in use","category":"debug","tags":["nodejs","networking","port","EADDRINUSE","server"],"problem":"Starting a server fails with Error: listen EADDRINUSE: address already in use :::3000. Another process is using the port, or a previous instance didn't shut down cleanly.","solution":"Find and kill the process using the port:\n\n# Find what's using the port\nlsof -i :3000          # macOS/Linux\nnetstat -ano | findstr :3000  # Windows\n\n# Kill it\nkill -9 $(lsof -t -i :3000)  # macOS/Linux\n\n# In Node.js, handle graceful shutdown\nprocess.on('SIGTERM', () => {\n  server.close(() => process.exit(0));\n});\n\n# Use a different port if needed\nconst port = process.env.PORT || 3001;\n\n# Or set SO_REUSEADDR\nconst server = app.listen(port);\nserver.on('error', (e) => {\n  if (e.code === 'EADDRINUSE') {\n    console.error(`Port ${port} in use, trying ${port + 1}`);\n    server.listen(port + 1);\n  }\n});","why":"Only one process can bind to a TCP port at a time. If a previous server crashed without closing the socket, the OS may keep the port in TIME_WAIT state for up to 60 seconds.","gotchas":["On macOS, AirPlay uses port 5000 by default","Docker containers bind to host ports — check docker ps","After a crash, the port may be in TIME_WAIT for 60 seconds","nodemon/ts-node-dev handle restarts but can leave zombie processes"],"language":"javascript","framework":null,"environment":["nodejs"],"error_messages":["Error: listen EADDRINUSE: address already in use :::3000","Error: listen EADDRINUSE","EADDRINUSE"],"keywords":["EADDRINUSE","port in use","kill process","lsof","address in use"],"severity":"major","context":"When starting a Node.js server and the port is already occupied","code_snippets":[{"lang":"bash","code":"# Find process on port 3000\nlsof -i :3000\n# Kill it\nkill -9 $(lsof -t -i :3000)","description":"Find and kill process on port"}],"version_info":null},
  {"title":"Express middleware order matters — put error handler last","category":"gotcha","tags":["nodejs","express","middleware","error-handling","routing"],"problem":"Express error handling middleware doesn't catch errors if it's defined before routes. Also, 404 handlers must come after all routes. Middleware executes in the order it's defined.","solution":"Order your middleware correctly:\n\nconst express = require('express');\nconst app = express();\n\n// 1. Built-in middleware FIRST\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(cors());\n\n// 2. Custom middleware (logging, auth)\napp.use(requestLogger);\napp.use('/api', authMiddleware);\n\n// 3. Routes\napp.use('/api/users', userRoutes);\napp.use('/api/posts', postRoutes);\n\n// 4. 404 handler (after all routes)\napp.use((req, res) => {\n  res.status(404).json({ error: 'Not found' });\n});\n\n// 5. Error handler LAST (must have 4 params!)\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Internal server error' });\n});","why":"Express processes middleware in order. If the error handler is defined before routes, it's never reached. Express identifies error handlers by their 4-parameter signature (err, req, res, next) — if you omit any parameter, it's treated as regular middleware.","gotchas":["Error handler MUST have exactly 4 parameters — even if you don't use next","Async errors need explicit next(err) or express-async-errors package","app.use without a path matches ALL routes","Static file middleware (express.static) should come before API routes"],"language":"javascript","framework":"express","environment":["nodejs"],"error_messages":["Cannot GET /path","UnhandledPromiseRejection","Error handler not catching errors"],"keywords":["express middleware order","error handler","404 handler","middleware chain","express-async-errors"],"severity":"major","context":"When setting up Express.js application middleware","code_snippets":[{"lang":"javascript","code":"// Error handler: MUST have 4 params\napp.use((err, req, res, next) => {\n  res.status(err.status || 500).json({ error: err.message });\n});\n\n// Async error handling\nconst asyncHandler = (fn) => (req, res, next) =>\n  Promise.resolve(fn(req, res, next)).catch(next);","description":"Express error handling pattern"}],"version_info":null},
  {"title":"dotenv must be loaded before importing other modules","category":"gotcha","tags":["nodejs","dotenv","env","configuration","import-order"],"problem":"Environment variables from .env are undefined when imported modules try to use them. require('dotenv').config() runs after the imports at the top of the file, but by then, imported modules have already read process.env.","solution":"Load dotenv as the very first thing:\n\n// Option 1: Preload via CLI (best)\nnode -r dotenv/config app.js\n\n// Option 2: Separate config file imported first\n// config.js\nimport 'dotenv/config';\n// app.js\nimport './config.js';  // MUST be first import\nimport express from 'express';\n\n// Option 3: Dynamic import after dotenv\nimport dotenv from 'dotenv';\ndotenv.config();\nconst { default: app } = await import('./app.js');\n\n// Option 4: Use dotenv-expand for variable references\n// .env: BASE_URL=http://localhost:${PORT}","why":"ES module imports are hoisted — they execute before any module-level code. So import 'dotenv/config' may run after other imports have already been evaluated. CommonJS require() executes in order, but ES modules don't.","gotchas":["In ESM, import order is NOT execution order — imports are hoisted","node -r dotenv/config works for both CJS and ESM","Don't commit .env files — use .env.example as a template","Docker and cloud platforms set env vars directly — .env is for local dev only"],"language":"javascript","framework":null,"environment":["nodejs"],"error_messages":["TypeError: Cannot read property of undefined","process.env.X is undefined"],"keywords":["dotenv","env undefined","import order","process.env","environment variables","preload"],"severity":"major","context":"When using dotenv for environment variable management in Node.js","code_snippets":[{"lang":"bash","code":"# Best: preload dotenv\nnode -r dotenv/config server.js\n\n# In package.json scripts\n\"scripts\": {\n  \"start\": \"node -r dotenv/config server.js\"\n}","description":"Preload dotenv via CLI"}],"version_info":null},
  {"title":"Node.js streams: pipe without error handling loses errors","category":"gotcha","tags":["nodejs","streams","pipe","error-handling","backpressure"],"problem":"Using stream.pipe(dest) doesn't forward errors. If the source stream errors, the destination is not closed, causing memory leaks. Errors are silently lost.","solution":"Use pipeline() from stream/promises (Node 15+) or handle errors manually:\n\nimport { pipeline } from 'stream/promises';\nimport { createReadStream, createWriteStream } from 'fs';\nimport { createGzip } from 'zlib';\n\n// Modern: pipeline handles errors and cleanup\nawait pipeline(\n  createReadStream('input.txt'),\n  createGzip(),\n  createWriteStream('output.gz')\n);\n\n// Manual error handling for .pipe()\nconst source = createReadStream('input.txt');\nconst dest = createWriteStream('output.txt');\nsource.on('error', (err) => dest.destroy(err));\ndest.on('error', (err) => source.destroy());\nsource.pipe(dest);","why":"pipe() only forwards data, not errors. It was designed before error handling patterns were standardized. pipeline() was added to fix this — it propagates errors through the entire chain and cleans up all streams.","gotchas":["pipeline() destroys all streams on error — pipe() doesn't","Backpressure is handled by pipe/pipeline — don't read faster than you write","stream.finished() callback tells you when a stream is done or errored","Always use { highWaterMark } option for controlling buffer size"],"language":"javascript","framework":null,"environment":["nodejs"],"error_messages":["Error: stream.push() after EOF","Error: write after end","ERR_STREAM_PREMATURE_CLOSE"],"keywords":["stream pipe","pipeline","error handling","backpressure","stream destroy","stream promises"],"severity":"major","context":"When piping Node.js streams for file processing, compression, or HTTP","code_snippets":[{"lang":"javascript","code":"import { pipeline } from 'stream/promises';\n\ntry {\n  await pipeline(source, transform, destination);\n  console.log('Done');\n} catch (err) {\n  console.error('Pipeline failed:', err);\n  // All streams are automatically cleaned up\n}","description":"Safe stream pipeline"}],"version_info":"Node.js 15+ for stream/promises"},
  {"title":"Buffer.from() vs deprecated new Buffer()","category":"gotcha","tags":["nodejs","buffer","security","deprecation"],"problem":"new Buffer(input) is deprecated and has a security vulnerability. If input is a number, it allocates uninitialized memory that may contain sensitive data from other processes.","solution":"Use the explicit Buffer.from() / Buffer.alloc() / Buffer.allocUnsafe():\n\n// String to buffer\nconst buf = Buffer.from('hello', 'utf8');\n\n// Allocate zeroed buffer (safe)\nconst zeroed = Buffer.alloc(1024);\n\n// Allocate uninitialized (fast but unsafe)\nconst fast = Buffer.allocUnsafe(1024);\nfast.fill(0);  // zero it manually if needed\n\n// From array\nconst arr = Buffer.from([0x68, 0x65, 0x6c]);\n\n// NEVER: new Buffer(size) — leaks memory contents\n// NEVER: new Buffer(userInput) — if userInput is a number, leaks memory","why":"new Buffer(n) allocated n bytes of uninitialized memory. An attacker could pass a large number to read contents of previously freed memory, potentially containing passwords or keys. Buffer.alloc() zeros the memory; Buffer.from() is for creating buffers from data.","gotchas":["Buffer.allocUnsafe() is faster but contains old memory — only use when you'll immediately fill it","Buffer.from(string) defaults to UTF-8 encoding","Buffer.isBuffer() to check if something is a Buffer","In ESM, Buffer is available globally — no import needed"],"language":"javascript","framework":null,"environment":["nodejs"],"error_messages":["DeprecationWarning: Buffer() is deprecated due to security and usability issues"],"keywords":["Buffer deprecation","new Buffer","Buffer.from","Buffer.alloc","uninitialized memory","security"],"severity":"critical","context":"When working with binary data in Node.js","code_snippets":[{"lang":"javascript","code":"// BAD: deprecated, security risk\nconst buf = new Buffer(100);  // uninitialized memory!\n\n// GOOD: explicit allocation\nconst safe = Buffer.alloc(100);     // zeroed\nconst data = Buffer.from('hello');  // from string","description":"Safe Buffer usage"}],"version_info":"Buffer.from/alloc available since Node.js 5.10"},
  {"title":"package.json scripts lifecycle hooks run automatically","category":"gotcha","tags":["nodejs","npm","package-json","scripts","lifecycle"],"problem":"npm has implicit script hooks that run automatically: preinstall, install, postinstall, prepare, prepublish. These can cause unexpected behavior — postinstall scripts run on npm install and can execute arbitrary code from dependencies.","solution":"Be aware of the lifecycle order:\n\nnpm install:\n  1. preinstall\n  2. install\n  3. postinstall\n  4. prepare (also runs on npm publish)\n\nnpm run <script>:\n  1. pre<script> (if exists)\n  2. <script>\n  3. post<script> (if exists)\n\n// Example: auto-build after install\n\"scripts\": {\n  \"build\": \"tsc\",\n  \"postinstall\": \"npm run build\",\n  \"pretest\": \"npm run lint\",\n  \"test\": \"jest\"\n}\n\n// Disable scripts from deps (security)\nnpm install --ignore-scripts\n\n// Or in .npmrc\nignore-scripts=true","why":"npm's lifecycle hooks were designed for build steps (compile native addons, transpile TypeScript). But they're also a supply chain attack vector — a malicious package can run arbitrary code during npm install via postinstall.","gotchas":["prepare runs on npm install in a git repo but NOT when installed as a dependency","npx also runs lifecycle scripts of packages it installs","--ignore-scripts breaks packages that need postinstall (like node-sass, sharp)","npm audit to check for known vulnerabilities in dependencies"],"language":"javascript","framework":null,"environment":["nodejs"],"error_messages":[],"keywords":["npm scripts","lifecycle hooks","postinstall","prepare","ignore-scripts","supply chain"],"severity":"moderate","context":"When managing npm scripts and understanding automatic execution hooks","code_snippets":[{"lang":"json","code":"{\n  \"scripts\": {\n    \"prebuild\": \"rm -rf dist\",\n    \"build\": \"tsc\",\n    \"postbuild\": \"cp package.json dist/\",\n    \"pretest\": \"npm run lint\",\n    \"test\": \"jest\"\n  }\n}","description":"npm lifecycle hooks example"}],"version_info":null},
  {"title":"V8 heap out of memory in Node.js","category":"debug","tags":["nodejs","memory","v8","heap","performance"],"problem":"Node.js crashes with FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory. Default heap limit is ~1.7GB for 64-bit systems.","solution":"Increase heap size or fix the memory issue:\n\n# Increase heap limit\nnode --max-old-space-size=4096 app.js  # 4GB\n\n# In package.json\n\"scripts\": {\n  \"start\": \"node --max-old-space-size=4096 app.js\"\n}\n\n# Environment variable (Node 20+)\nNODE_OPTIONS='--max-old-space-size=4096' node app.js\n\n# Find the leak\nnode --inspect app.js\n# Open chrome://inspect, take heap snapshots, compare\n\n# Common causes:\n# 1. Unbounded arrays/caches growing forever\n# 2. Event listeners not cleaned up\n# 3. Closures holding references to large objects\n# 4. Reading entire large files into memory (use streams instead)","why":"V8 has a default heap limit to prevent runaway processes from consuming all system memory. The limit is typically 1.4-1.7GB for 64-bit systems. For memory-intensive tasks (large datasets, image processing), you need to increase it.","gotchas":["--max-old-space-size is in MB not GB","Setting it too high can cause the OS to swap/OOM kill","Use streams for large file processing instead of readFileSync","Global variables and module-level caches are never garbage collected"],"language":"javascript","framework":null,"environment":["nodejs"],"error_messages":["FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory","FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed","JavaScript heap out of memory"],"keywords":["heap out of memory","max-old-space-size","memory leak","V8 heap","garbage collection","node memory"],"severity":"major","context":"When Node.js process runs out of memory during large data processing or has a memory leak","code_snippets":[{"lang":"bash","code":"# Run with increased heap\nnode --max-old-space-size=4096 app.js\n\n# Debug memory\nnode --inspect --expose-gc app.js\n# Then: chrome://inspect → Take Heap Snapshot","description":"Increase Node.js heap and debug memory"}],"version_info":"NODE_OPTIONS env var for heap size: Node 8+"},
  {"title":"React useEffect cleanup function prevents memory leaks","category":"pattern","tags":["react","hooks","useEffect","cleanup","memory-leak"],"problem":"useEffect without a cleanup function causes memory leaks when the component unmounts — subscriptions stay active, timers keep running, and fetch responses try to update unmounted components.","solution":"Always return a cleanup function from useEffect:\n\nuseEffect(() => {\n  // Setup\n  const subscription = api.subscribe(data => setData(data));\n  const timer = setInterval(() => tick(), 1000);\n  const controller = new AbortController();\n  \n  fetch('/api/data', { signal: controller.signal })\n    .then(res => res.json())\n    .then(data => setData(data))\n    .catch(err => {\n      if (err.name !== 'AbortError') throw err;\n    });\n\n  // Cleanup — runs on unmount or before re-running effect\n  return () => {\n    subscription.unsubscribe();\n    clearInterval(timer);\n    controller.abort();  // cancels fetch\n  };\n}, []);  // dependency array","why":"React calls the cleanup function before the component unmounts AND before re-running the effect (when dependencies change). Without cleanup, subscriptions and timers persist after the component is gone, causing memory leaks and 'setState on unmounted component' warnings.","gotchas":["Cleanup runs BEFORE each re-execution of the effect, not just on unmount","AbortController is the modern way to cancel fetch requests","The empty dependency array [] means effect runs once (mount) and cleanup runs once (unmount)","In React 18 strict mode, effects run twice in development to catch missing cleanups"],"language":"javascript","framework":"react","environment":["browser"],"error_messages":["Warning: Can't perform a React state update on an unmounted component","AbortError: The operation was aborted"],"keywords":["useEffect cleanup","memory leak","unmount","subscription","AbortController","setState unmounted"],"severity":"major","context":"When using useEffect with subscriptions, timers, or async operations","code_snippets":[{"lang":"javascript","code":"useEffect(() => {\n  const controller = new AbortController();\n  fetch(url, { signal: controller.signal })\n    .then(r => r.json())\n    .then(setData)\n    .catch(e => { if (e.name !== 'AbortError') throw e; });\n  return () => controller.abort();\n}, [url]);","description":"Cancelable fetch in useEffect"}],"version_info":"React 16.8+ for hooks"},
  {"title":"React stale closure in useEffect and callbacks","category":"gotcha","tags":["react","hooks","closure","stale-state","useRef"],"problem":"State variables inside useEffect or callbacks capture the value at the time the effect/callback was created. If the dependency array doesn't include the variable, you see stale (old) values.","solution":"Include all dependencies in the dependency array, or use useRef for mutable values:\n\n// Problem: stale count\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    const id = setInterval(() => {\n      console.log(count);  // Always 0! Stale closure\n      setCount(count + 1); // Always sets to 1\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);  // count not in deps\n\n  // Fix 1: Add count to deps (re-creates interval each time)\n  useEffect(() => {\n    const id = setInterval(() => setCount(count + 1), 1000);\n    return () => clearInterval(id);\n  }, [count]);\n\n  // Fix 2: Use functional update (best for this case)\n  useEffect(() => {\n    const id = setInterval(() => setCount(c => c + 1), 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  // Fix 3: useRef for latest value\n  const countRef = useRef(count);\n  countRef.current = count;\n  useEffect(() => {\n    const id = setInterval(() => console.log(countRef.current), 1000);\n    return () => clearInterval(id);\n  }, []);\n}","why":"JavaScript closures capture variables by reference, but React state creates new values on each render. The effect closure captures the state value from the render it was created in. Without re-running the effect, it never sees new values.","gotchas":["ESLint react-hooks/exhaustive-deps catches most stale closure bugs","Functional updates setCount(c => c + 1) avoid the dependency entirely","useRef.current is always the latest value — useful for event handlers","This is the #1 source of bugs in React hooks code"],"language":"javascript","framework":"react","environment":["browser"],"error_messages":[],"keywords":["stale closure","useEffect deps","useRef","functional update","dependency array","react hooks"],"severity":"major","context":"When state values appear stale inside useEffect or event handler callbacks","code_snippets":[{"lang":"javascript","code":"// Functional update avoids stale closure\nsetCount(prev => prev + 1);  // always uses latest\n\n// useRef for latest value in callbacks\nconst latestCount = useRef(count);\nlatestCount.current = count;","description":"Avoiding stale closures"}],"version_info":"React 16.8+"},
  {"title":"React keys must be stable — don't use array index for dynamic lists","category":"gotcha","tags":["react","keys","lists","rendering","performance"],"problem":"Using array index as key in lists causes bugs when items are reordered, added, or removed. React uses keys to match elements between renders — index keys cause incorrect state preservation and unnecessary re-renders.","solution":"Use a stable, unique identifier as key:\n\n// BAD: index as key\n{items.map((item, index) => (\n  <ListItem key={index} item={item} />  // breaks on reorder/delete\n))}\n\n// GOOD: unique ID\n{items.map(item => (\n  <ListItem key={item.id} item={item} />\n))}\n\n// If no ID exists, generate one when data is created (not during render)\nconst itemsWithIds = rawItems.map(item => ({\n  ...item,\n  id: crypto.randomUUID()  // generated once, not on every render\n}));\n\n// Index is OK for static lists that never change:\n{['Home', 'About', 'Contact'].map((label, i) => (\n  <NavLink key={i}>{label}</NavLink>  // fine — list never changes\n))}","why":"React uses keys to determine which elements to update, add, or remove. With index keys, if you delete item 2 from a list of 5, items 3-5 get new indexes (2-4), so React thinks items 3-5 changed and re-renders them instead of just removing item 2. Worse, component state (inputs, focus) gets attached to the wrong items.","gotchas":["Never generate keys during render (Math.random()) — it remounts every time","Index keys are fine for static, non-reorderable lists","Keys only need to be unique among siblings, not globally","Fragments (<>...</>) can't have keys — use <Fragment key={id}> instead"],"language":"javascript","framework":"react","environment":["browser"],"error_messages":["Warning: Each child in a list should have a unique \"key\" prop"],"keywords":["react key","list key","index key","unique key","reorder bug","key prop"],"severity":"major","context":"When rendering lists of items in React that can be reordered, added, or deleted","code_snippets":[{"lang":"javascript","code":"// Always use stable IDs\n{users.map(user => (\n  <UserCard key={user.id} user={user} />\n))}\n\n// NOT: key={index}\n// NOT: key={Math.random()}","description":"Correct key usage in React lists"}],"version_info":null},
  {"title":"React setState is batched — state isn't updated immediately","category":"gotcha","tags":["react","state","batching","async","hooks"],"problem":"Calling setState and immediately reading the state variable gives the OLD value. React batches state updates and applies them on the next render, not synchronously.","solution":"Use functional updates or useEffect to read updated state:\n\n// BAD: reading stale state after setState\nconst [count, setCount] = useState(0);\nfunction handleClick() {\n  setCount(count + 1);\n  console.log(count);  // Still 0!\n  setCount(count + 1);\n  console.log(count);  // Still 0! Both set to 1\n}\n\n// GOOD: functional update for sequential increments\nfunction handleClick() {\n  setCount(c => c + 1);  // 0 → 1\n  setCount(c => c + 1);  // 1 → 2\n}\n\n// GOOD: useEffect to react to state changes\nuseEffect(() => {\n  console.log('count is now:', count);\n}, [count]);","why":"React batches all setState calls within an event handler and applies them at once before re-rendering. This is a performance optimization — it prevents unnecessary intermediate renders. In React 18+, batching also applies to async callbacks, timeouts, and promises.","gotchas":["React 18 batches ALL setState calls (even in setTimeout/promises)","React 17 only batched in event handlers — async code was NOT batched","flushSync() forces immediate re-render if absolutely needed (rare)","Class component this.setState has the same batching behavior"],"language":"javascript","framework":"react","environment":["browser"],"error_messages":[],"keywords":["setState batching","state not updating","stale state","functional update","flushSync","React 18 batching"],"severity":"major","context":"When reading state immediately after calling setState in React","code_snippets":[{"lang":"javascript","code":"// Wrong: both read count=0\nsetCount(count + 1);  // sets to 1\nsetCount(count + 1);  // sets to 1 (not 2!)\n\n// Right: functional update chains correctly\nsetCount(c => c + 1);  // 0 → 1\nsetCount(c => c + 1);  // 1 → 2","description":"Functional state updates"}],"version_info":"React 18+ for automatic batching everywhere"},
  {"title":"Next.js: 'use client' directive needed for hooks and interactivity","category":"gotcha","tags":["react","nextjs","server-components","client-components","app-router"],"problem":"Using useState, useEffect, onClick, or any interactivity in a Next.js 13+ App Router component fails with Error: useState only works in Client Components. Add the 'use client' directive. By default, all components are Server Components.","solution":"Add 'use client' at the top of files that need interactivity:\n\n// This file uses hooks — must be a client component\n'use client';\n\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;\n}\n\n// Server Components (default) can:\n// - Fetch data directly (async/await)\n// - Access backend resources\n// - Keep secrets server-side\n// - Reduce client bundle size\n\n// Pattern: Server Component wraps Client Component\n// page.tsx (Server — fetches data)\nexport default async function Page() {\n  const data = await fetchData();\n  return <InteractiveList data={data} />;  // passes data down\n}\n// InteractiveList.tsx ('use client' — handles interaction)","why":"Next.js App Router uses React Server Components by default. Server Components render on the server only — they can't use browser APIs, hooks, or event handlers. 'use client' marks the boundary where client-side JavaScript begins.","gotchas":["'use client' must be at the very top of the file, before imports","A Client Component can import Server Components only as children (props.children)","Server Components can import and render Client Components","Don't put 'use client' on every component — push it as far down the tree as possible"],"language":"javascript","framework":"nextjs","environment":["browser","nodejs"],"error_messages":["Error: useState only works in Client Components","Error: Event handlers cannot be passed to Client Component props","You're importing a component that needs useState"],"keywords":["use client","server components","client components","Next.js 13","App Router","useState server"],"severity":"major","context":"When using React hooks or event handlers in Next.js 13+ App Router","code_snippets":[{"lang":"javascript","code":"'use client'; // MUST be first line\n\nimport { useState } from 'react';\n\nexport function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'ON' : 'OFF'}</button>;\n}","description":"Client Component in Next.js App Router"}],"version_info":"Next.js 13+ with App Router"},
  {"title":"React Context re-renders all consumers on any value change","category":"gotcha","tags":["react","context","performance","re-renders","optimization"],"problem":"When a Context value changes, ALL components that consume that context re-render — even if they only use a part of the value that didn't change. This causes performance issues with large context objects.","solution":"Split context by update frequency, or use memoization:\n\n// BAD: one giant context\nconst AppContext = createContext({ user, theme, settings, cart });\n// Changing cart re-renders components that only use theme\n\n// GOOD: split into separate contexts\nconst UserContext = createContext(null);\nconst ThemeContext = createContext('light');\nconst CartContext = createContext([]);\n\n// GOOD: memoize context value\nfunction Provider({ children }) {\n  const [user, setUser] = useState(null);\n  const value = useMemo(() => ({ user, setUser }), [user]);\n  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;\n}\n\n// GOOD: use a selector library (use-context-selector, zustand)\nimport { useContextSelector } from 'use-context-selector';\nconst name = useContextSelector(UserContext, ctx => ctx.user.name);","why":"React context doesn't have fine-grained subscriptions. When the Provider value changes (by reference), React walks the component tree and re-renders every Consumer. If the value is a new object on each render ({...}), every consumer re-renders every time.","gotchas":["value={{ a, b }} creates a new object every render — always memoize","Context is not a state management replacement — it's for dependency injection","Zustand or Jotai provide fine-grained subscriptions without extra context","React.memo on consumers doesn't help — context bypasses memo"],"language":"javascript","framework":"react","environment":["browser"],"error_messages":[],"keywords":["context re-renders","context performance","useMemo context","split context","context selector"],"severity":"moderate","context":"When React context causes unnecessary re-renders in large applications","code_snippets":[{"lang":"javascript","code":"// Memoize context value\nconst value = useMemo(() => ({ user, login, logout }), [user]);\n<AuthContext.Provider value={value}>\n  {children}\n</AuthContext.Provider>","description":"Memoized context value"}],"version_info":"React 16.3+ for createContext"},
  {"title":"React controlled vs uncontrolled input warning","category":"gotcha","tags":["react","forms","controlled","uncontrolled","input"],"problem":"React warns: 'A component is changing an uncontrolled input to be controlled.' This happens when an input starts with undefined value and later gets a defined value, or vice versa.","solution":"Ensure the value is never undefined:\n\n// BAD: value starts as undefined\nconst [name, setName] = useState();  // undefined\n<input value={name} />  // uncontrolled → controlled when name is set\n\n// GOOD: initialize with empty string\nconst [name, setName] = useState('');\n<input value={name} onChange={e => setName(e.target.value)} />\n\n// For checkboxes\nconst [checked, setChecked] = useState(false);  // not undefined\n<input type='checkbox' checked={checked} onChange={e => setChecked(e.target.checked)} />\n\n// Fallback for possibly undefined values\n<input value={name ?? ''} onChange={...} />\n<input value={name || ''} onChange={...} />","why":"React has two modes for inputs: controlled (value prop set) and uncontrolled (no value prop, or value=undefined). Switching between modes during the component lifecycle causes unpredictable behavior. React warns because it can't tell if this was intentional.","gotchas":["null and undefined both make an input uncontrolled — use empty string ''","defaultValue is for uncontrolled inputs only — don't mix with value","Textarea and select follow the same controlled/uncontrolled rules","react-hook-form uses uncontrolled inputs by default (refs, not state)"],"language":"javascript","framework":"react","environment":["browser"],"error_messages":["Warning: A component is changing an uncontrolled input to be controlled","Warning: A component is changing a controlled input to be uncontrolled"],"keywords":["controlled input","uncontrolled input","input warning","form state","undefined value"],"severity":"moderate","context":"When building forms in React with controlled inputs","code_snippets":[{"lang":"javascript","code":"// Always initialize form state with defined values\nconst [form, setForm] = useState({\n  name: '',       // not undefined\n  email: '',      // not undefined\n  agreed: false,  // not undefined\n});","description":"Properly initialized form state"}],"version_info":null},
  {"title":"React.memo doesn't prevent re-renders from new object/array props","category":"gotcha","tags":["react","memo","performance","re-renders","optimization"],"problem":"Wrapping a component in React.memo but passing inline objects, arrays, or functions as props still causes re-renders. memo does shallow comparison — new references (even with same content) are 'different'.","solution":"Memoize props with useMemo/useCallback:\n\n// Parent component\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  // BAD: new object every render defeats memo\n  // <Child style={{ color: 'red' }} />\n\n  // GOOD: stable reference\n  const style = useMemo(() => ({ color: 'red' }), []);\n  const handleClick = useCallback(() => doSomething(), []);\n\n  return <Child style={style} onClick={handleClick} />;\n}\n\nconst Child = React.memo(function Child({ style, onClick }) {\n  return <div style={style} onClick={onClick}>...</div>;\n});\n\n// Or use a custom comparison function\nconst Child = React.memo(Component, (prevProps, nextProps) => {\n  return prevProps.id === nextProps.id;  // only re-render if id changes\n});","why":"React.memo shallow-compares each prop. {} === {} is false in JavaScript — every render creates new objects even if the content is identical. useMemo and useCallback return the same reference across renders when dependencies haven't changed.","gotchas":["Don't overuse memo/useMemo/useCallback — they have overhead too","Primitive props (strings, numbers, booleans) are compared by value — always stable","Children prop is often a new JSX object — this defeats memo","Profile first, optimize second — most re-renders are fine"],"language":"javascript","framework":"react","environment":["browser"],"error_messages":[],"keywords":["React.memo","useMemo","useCallback","shallow comparison","re-render optimization","reference equality"],"severity":"moderate","context":"When optimizing React component re-renders with memo","code_snippets":[{"lang":"javascript","code":"// Stable references prevent memo re-renders\nconst config = useMemo(() => ({ theme: 'dark' }), []);\nconst onClick = useCallback(() => save(), [save]);\n\n<MemoizedChild config={config} onClick={onClick} />","description":"Stable props for memoized components"}],"version_info":"React 16.6+ for React.memo"},
  {"title":"Next.js Image component requires width and height or fill","category":"gotcha","tags":["react","nextjs","image","optimization","layout"],"problem":"Next.js Image component requires explicit width and height props, or the fill prop. Without them, it throws an error. Remote images also need configuration in next.config.js.","solution":"Provide dimensions or use fill mode:\n\nimport Image from 'next/image';\n\n// Fixed dimensions\n<Image src='/photo.jpg' width={800} height={600} alt='Photo' />\n\n// Fill parent container\n<div style={{ position: 'relative', width: '100%', height: 300 }}>\n  <Image src='/photo.jpg' fill style={{ objectFit: 'cover' }} alt='Photo' />\n</div>\n\n// Remote images: configure domains in next.config.js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      { protocol: 'https', hostname: '**.example.com' },\n    ],\n  },\n};\n\n// With blur placeholder\n<Image src='/photo.jpg' width={800} height={600}\n  placeholder='blur' blurDataURL='data:image/...' alt='Photo' />","why":"Next.js Image optimizes images by generating multiple sizes, lazy loading, and serving modern formats (WebP/AVIF). It needs dimensions upfront to reserve space and prevent layout shift (CLS). fill mode makes the image fill its positioned parent.","gotchas":["fill requires the parent to have position: relative","Remote images need remotePatterns in next.config.js — domains alone is deprecated","sizes prop is important for responsive images with fill to avoid downloading oversized images","priority prop disables lazy loading — use for above-the-fold images"],"language":"javascript","framework":"nextjs","environment":["browser","nodejs"],"error_messages":["Error: Image with src X must use width and height properties or fill property","Error: Invalid src prop on next/image, hostname is not configured"],"keywords":["Next.js Image","image optimization","width height","fill prop","remotePatterns","layout shift"],"severity":"moderate","context":"When using the Next.js Image component for optimized images","code_snippets":[{"lang":"javascript","code":"// next.config.js for remote images\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      { protocol: 'https', hostname: 'cdn.example.com' },\n    ],\n  },\n};","description":"Next.js remote image config"}],"version_info":"Next.js 13+ for remotePatterns"}
]